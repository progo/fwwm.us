<html><head><meta content="text/html; charset=utf-8" http-equiv="content-type" /><script type="text/x-mathjax-config">/* Fix org-generated pictures to MathJX. Big thanks to Davide Cervone
  on StackOverflow with this. http://stackoverflow.com/a/14631703/308668
  */
MathJax.Extension.myImg2jax = {
    version: "1.0",
    PreProcess: function (element) {
        var images = element.getElementsByTagName("img");
        for (var i = images.length - 1; i >= 0; i--) {
            var img = images[i];
            if (img.className === "dvipng") {
                var script = document.createElement("script");
                script.type = "math/tex";
                var match = img.alt.match(/^(\$\$?)(.*)\1/);
                if (match[1] === "$$") {script.type += ";mode=display"}
                MathJax.HTML.setScript(script,match[2]);
                img.parentNode.replaceChild(script,img);
            }
        }
    }
};
MathJax.Hub.Register.PreProcessor(["PreProcess",MathJax.Extension.myImg2jax]);
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script><link href="http://fwwm.us/css/main.css" rel="stylesheet" type="text/css" /><title>Tehokas reduce - Life at the Room.</title><link href="http://fwwm.us/css/koodi.css" rel="stylesheet" type="text/css" /></head><body><div id="sidebar-left"><div id="post-info"><div id="navi"><span class="title">Navigointi</span><ul id="navi-list"><li class="fp"><a href="http://fwwm.us/">Etusivulle</a></li><li><a href="http://fwwm.us/koodi/index.html">Koodi</a></li><li><a href="..">helmikuu</a></li><li><a href="../..">2013</a></li></ul></div><span class="title">Info</span><p class="date">Julkaistu<br />16.02.2013 20:12</p></div><div id="post-tags"><span class="title">Tagit</span><ul id="tags-list"><li><div class="taggy"><div class="taggy-inner"><a href="http://fwwm.us/tag/clojure/index.html">clojure</a></div></div></li><li><div class="taggy"><div class="taggy-inner"><a href="http://fwwm.us/tag/fp/index.html">fp</a></div></div></li></ul></div></div><div id="content"><div class="post-content">
<h1>Tehokas <code>reduce</code>    </h1>
<div id="text-3-2" class="outline-text-3">




<p>
   Funktionaalisen ohjelmoinnin kolme keskeisintä työkalua ovat
   eittämättä korkeamman asteen funktiot <code>map</code>, <code>reduce</code> ja <code>filter</code>,
   joista kullakin on omanlaisensa tehtävä. Näistä kuitenkin <code>reduce</code>
   voittaa yleisyydessä kevyesti.
</p>
<p>   
   Esittelen tässä postauksessa funktionaalisten kielten perusteisiin
   kuuluvana asiana kuinka nämä funktiot voitaisiin kirjoittaa ja
   sitten, miten <code>reduce</code> voi korvata sekä <code>map</code>-, että
   <code>filter</code>-funktiot.
</p>

</div>

<div class="outline-4" id="outline-container-3-2-1">
<h2><code>map</code></h2>
<div id="text-3-2-1" class="outline-text-4">


<p>
    Funktio <code>map</code> on niin klassinen työväline listojen käsittelyssä,
    että se tuntuu uponneen kertaheitolla kaaliin. Matemaattisesti
    <code>map</code> ei ole paljoa muuta kuin funktion soveltaminen kokonaiseen
    joukkoon, usein kirjoitettuna näin: 
    <img class="dvipng" alt="$$f(A) := \{ f(a) \mid a \in A \}.$$" src="http://fwwm.us/upload/blog_36fb715e8e3bda6094f2cf9bc2d043ee2349173e.png" /> 
</p>
<p>    
    Funktionaaliset kielet pelaavat jonojen, usein listojen parissa.
    Siispä matemaattinen joukkonotaatio ja joukkojen kanssa
    puljautuminen siirtyy listoiksi. Clojure osaa toki soveltaa
    <code>map</code>-funktiota joukkoihinkin, koska joukot toteuttavat yleisemmän
    jonoabstraktion.
</p>
<p>    
    <code>map</code> ottaa siis tavallisesti kaksi argumenttia; ensin käytettävän
    funktion ja toisena kokoelman alkioita, joihin funktiota
    sovelletaan. Clojuressa kokoelmia saa toimittaa mielivaltaisen
    monta. Tällöin kustakin joukosta poimitaan kerralla yksi
    argumentti annettavaksi funktiolle.
</p>
<p>    
    Funktionaaliseen tapaan kirjoitamme toteutukset rekursiiviseen
    tapaan.
</p>



<pre class="example">(defn map [fun coll]
  (loop [fun fun, coll (seq coll), acc ()]
    (if-let [x (first coll)]
      (recur fun
             (rest coll)
             (concat acc (list (fun x))))
      acc)))

(defn map' [fun coll]
  (if-let [x (first coll)]
    (cons (fun x)
          (map' fun (rest coll)))))
</pre>


<p>    
    Tässä on kaksi naiivia, perustason esimerkkiä, miten <code>map</code>:n voisi
    toteuttaa. Ensimmäinen käyttää rekursiivisuuteen Clojuren
    toteuttamaa <code>loop-recur</code> -rakennetta, jolla häntärekursio saadaan
    kuriin. Tuloksena on myös hieman rumempaa koodia.
</p>
<p>    
    Toinen tapa on perinteisempi funktionaalinen tapa, jota
    Haskell-ihmiset varmasti muistavat kehua. Rakennamme hyvin
    perinteisellä <code>cons</code>-metodilla saman listan. <code>cons</code> eli
    <i>construct</i> lisää ensimmäisen argumenttinsa toisen argumentin
    alkuun.
</p>
<p>    
    Haskellissa on vastaavanlainen listojen rakennusmenetelmä, eli
    lyhyt oppimäärä: <img class="dvipng" alt="$x : [a, b, c] == [x, a, b, c]$" src="http://fwwm.us/upload/blog_1b0db1165a65d6ca7704293a72db5696b876955c.png" />. Kaksoispiste
    <code>:</code> toimii konstruktorina. Tästä sitten rekursiivisesti voimme
    sanoa, että <img class="dvipng" alt="$1 : 2 : 3 : []$" src="http://fwwm.us/upload/blog_dee18d53c257b3c8afacffcd674d81c8e7aa036a.png" /> on sama lista kuin <img class="dvipng" alt="$[1, 2, 3]$" src="http://fwwm.us/upload/blog_bca6f41e5fbace0d004fa84a9facec2c8a80c0fc.png" />.
    Ylimääräiset sulut voimme näet jättää pois tässä yhteydessä.
</p>
<p>    
    Yhtä kaikki, JVM ei tue häntärekursiota, eli jälkimmäinen
    menetelmä kannattaa suosiolla unohtaa. Liian isojen kokoelmien
    kanssa kutsupino kasvaa ylitse. Clojure valitsi eksplisiittisen
    merkinnän, <code>loop--recur</code>, jolla optimoitavissa oleva rekursio
    voidaan ilmaista. Clojuren oikea <code>map</code>-toteutus käyttää laiskoja
    listoja ja niiden kanssa käytettävää makrorakennetta, ja se on
    kokonaan toisennäköinen.
</p>
</div>

</div>

<div class="outline-4" id="outline-container-3-2-2">
<h2><code>filter</code></h2>
<div id="text-3-2-2" class="outline-text-4">


<p>    
    Kokoelman suodatus epäkelvon aineksen pyyhkimiseksi on myös eräs
    hyvin yleinen probleema. <code>filter</code> jättää siis kaikki ne alkiot
    kokoelmasta jäljelle, joille predikaatti antaa toden.
</p>
<p>    
    Ohessa seuraa edellistä <code>map</code>-koodia mukaileva ratkaisu.
    Pilkullinen versio on taasen se naivi esitys matemaattisesta
    ideasta taustalla. Jos alkio täyttää ehdon, otetaan se mukaan ja
    haetaan sitten loput filtteröidyt alkiot uuden kutsun voimin. Eri kätevää.
</p>



<pre class="example">(defn filter [pred coll]
  (loop [pred pred, coll coll, acc ()]
    (if-let [x (first coll)]
      (if (pred x)
        (recur pred (rest coll) (concat acc (list x)))
        (recur pred (rest coll) acc))
      acc)))

(defn filter' [pred coll]
  (if-let [x (first coll)]
    (if (pred x)
      (cons x (filter' pred (rest coll)))
      (filter' pred (rest coll)))))
</pre>


</div>

</div>

<div class="outline-4" id="outline-container-3-2-3">
<h2><code>reduce</code></h2>
<div id="text-3-2-3" class="outline-text-4">


<p>    
    Reduktiot kokoelmista yhdeksi skalaariksi. Yleisiä ongelmia.
    Haskellissa <code>foldl</code>, Rubyssä <code>inject</code> ja muissa kielissä <code>reduce</code>
    tekee homman.
</p>
<p>    
    <code>reduce</code> tarvitsee kahden muuttujan funktion, jolle se syöttää
    aina uuden alkion kokoelmasta. Kertymämuuttuja alustetaan yleensä
    funktiolle ominaisen neutraalialkion kanssa: yhteenlaskun
    tapauksessa 0 on luonnollinen, tulon kanssa 1, ja sitä rataa.
</p>
<p>    
    Kun ovelana käytämme alkuarvoa <code>x0</code> myös kertymämuuttujana, saamme
    itse asiassa aikaan kaikkein sievintä koodia:
</p>



<pre class="example">(defn reduce [fun x0 coll]
  (if-let [x (first coll)]
    (recur fun (fun x0 x) (rest coll))
    x0))
</pre>


<p>    
    Kaikilla näillä funktioilla on määrittelyssä yhteisiä piirteitä:
    kaikista otetaan ensialkio talteen, ja jos ei saada sellaista niin
    rekursio lopetetaan (joukko <code>coll</code> on selvästi tyhjä siinä
    pisteessä).
</p>
</div>

</div>

<div class="outline-4" id="outline-container-3-2-4">
<h2><code>reduce</code> voittaa</h2>
<div id="text-3-2-4" class="outline-text-4">


<p>    
    Pienellä notkeudella tutkikaamme, miten <code>map</code>- ja
    <code>filter</code>-funktiot voisi toteuttaa <code>reduce</code>:n avulla. Meidän
    tarvitsee vain kirjoittaa sopivanlainen funktio ja alkuarvo
    lähetettäväksi.
</p>
<ul>
<li id="sec-3-2-4-1"><code>map</code> <code>reduce</code>:n avulla<br />

<p>    
     <code>map</code> kuvaa funktiolla joukon toisenlaiseksi joukoksi:
     reduktio-funktiomme voisi olla tämännäköinen:
</p>



<pre class="example">(defn mapr [fun coll]
  (let [f (fn [xs x]
            (concat xs (list (fun x))))]
    (reduce f () coll)))
</pre>


<p>     
     Vaikka <code>reduce</code> toimii idealla "kokoelma yhdeksi skalaariksi", on
     Clojuressa skalaarin käsite hieman häilyvä. Funktiomme palauttaa
     itse asiassa koko listan <b>plus</b> yhden uuden (ja käsitellyn)
     alkion, täten replikoiden <code>map</code>-funktion toiminnallisuuden.
</p>
</li>
</ul>
<ul>
<li id="sec-3-2-4-2"><code>filter</code> <code>reduce</code>:n avulla<br />

<p>
     Samalla menettelyllä kirjoitetaan <code>filter</code>.
</p>



<pre class="example">(defn filterr [pred coll]
  (let [f (fn [xs x]
            (if (pred x)
              (concat xs (list x))
              xs))]
    (reduce f () coll)))
</pre>


<p>     
     Syntyy tavallaan jopa alkuperäistä sievempää koodia.
</p>
</li>
</ul>
</div>

</div>

<div class="outline-4" id="outline-container-3-2-5">
<h2>Mitä tästä opimme?</h2>
<div id="text-3-2-5" class="outline-text-4">


<p>    
    Että nyt kaikki kirjoittamaan reduktioita? Ei. Yksi asia, missä
    <code>map</code> ja <code>filter</code> eroavat kovasti tosielämän <code>reduce</code>:sta on
    niiden laiskuus. Laiskuutta en tässä voinut demonstroida, mutta
    <code>reduce</code> on määritelmältään epälaiska funktio. Sen on saatava
    evaluoitua kaikki annetut argumenttinsa, jotta se pääsee
    suoriutumaan.
</p>
<p>
    Tärkeämpää on ottaa opikseen näistä esimerkeistä <code>reduce</code>:n voima.
    Esimerkkinä useiden kuvausten yhdistäminen: ennen tätä oppimäärää
    olisin luultavasti tyytynyt siihen seikkaan, että clojuren oma
    <code>merge</code>-funktio toimii vain kahden kuvauksen kanssa, ja olisin
    kirjoittanut <code>loop-recur</code>-rakenteen yhdistämään mielivaltaisen
    monta kuvausta keskenään. Nyt voin kutsua yksinkertaisemmin:
    <code>(reduce merge my-maps)</code>, ja siirtyä muihin ongelmiin.
</p>
<p>    
    Se, että <code>reduce</code>:a aina opetetaan käyttämällä oikeita skalaareja,
    saattaa hämätä itse kutakin. Kaikki on mahdollista, vaikkapa
    funktiokompositiokin, saada aikaan <code>reduce</code>:n voimin.
</p></div>
</div>

</div><div id="disqus_thread"></div>

<script type="text/javascript">
    // :sb__ stuff is replaced in clojure
    var disqus_shortname = 'progim';
    var disqus_identifier = '20130216_2012';

    (function() {
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] ||
         document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>

<noscript>Please enable JavaScript to view the <a
href="http://disqus.com/?ref_noscript">comments powered by
Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by
<span class="logo-disqus">Disqus</span></a>
</div></body></html>