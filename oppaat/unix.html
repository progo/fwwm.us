<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <script type="text/x-mathjax-config">
        /* Fix org-generated pictures to MathJX. Big thanks to Davide Cervone
          on StackOverflow with this. http://stackoverflow.com/a/14631703/308668
          */
        MathJax.Extension.myImg2jax = {
            version: "1.0",
            PreProcess: function (element) {
                var images = element.getElementsByTagName("img");
                for (var i = images.length - 1; i >= 0; i--) {
                    var img = images[i];
                    if (img.className === "dvipng") {
                        var script = document.createElement("script");
                        script.type = "math/tex";
                        var match = img.alt.match(/^(\$\$?)(.*)\1/);
                        if (match[1] === "$$") {script.type += ";mode=display"}
                        MathJax.HTML.setScript(script,match[2]);
                        img.parentNode.replaceChild(script,img);
                    }
                }
            }
        };
        MathJax.Hub.Register.PreProcessor(["PreProcess",MathJax.Extension.myImg2jax]);
    </script>
    <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript">
    </script>
    <link href="/templates/main.css" media="screen" type="text/css" rel="stylesheet" />
  
  <title>Thinking in Text — fwwm.us</title>
  <link />
</head>
  <body>
    <div id="backgrounds">
      <div id="header">
        <h1 id="site-title">fwwm.us</h1>
      </div>
      <div id="sidebar">
  <ul id="navigation" class="navi-list">
    <li><a href="/">Ylös</a></li>
    <li><a href="/all.html">Kaikki jutut</a></li>
    <!-- <li><a href=".">RSS</a></li> -->
  </ul>
  <ul class="info-list">
    <li>
      <div>
        <span class="value" id="post-created">19.05.2014</span>
        <span class="key">Luotu</span>
      </div>
    </li>
    <li>
      <div>
        <span class="value" id="post-modified">19.05.2014</span>
        <span class="key">Päivitetty</span>
      </div>
    </li>
    <li>
      <a href="https://github.com/progo/fwwmus---org/commits/main/oppaat/unix.org" id="post-revs-url">
        <span>Muutoshistoria</span>
      </a>
    </li>
  </ul>

  <h2>Tagit</h2>
  <ul id="tags" class="tag-list"><li class="tag-0"><a href="/tags/unix.html" class="tag-name">unix</a></li><li class="tag-0"><a href="/tags/oppaat.html" class="tag-name">oppaat</a></li></ul>

  <h2 id="related-posts-title">Aiheen vierestä</h2>
  <ul id="related-posts">
    <li>
      <a href="/progo.html" class="rp-url">
        <span class="rp-title">Mikael 'progo' Puhakka, tiivistetty haastattelu</span>
      </a>
    </li><li>
      <a href="/miete/canto.html" class="rp-url">
        <span class="rp-title">Canto on uusi RSS-lukijani</span>
      </a>
    </li><li>
      <a href="/miete/pelisavetukset-versiohallintaan.html" class="rp-url">
        <span class="rp-title">Pelisavetukset versiohallintaan</span>
      </a>
    </li><li>
      <a href="/miete/uusi-blogi-on-out.html" class="rp-url">
        <span class="rp-title">Uusi blogi on nyt out live</span>
      </a>
    </li><li>
      <a href="/miete/naytonsaastajaskriptit.html" class="rp-url">
        <span class="rp-title">Näytönsäästäjäskriptit</span>
      </a>
    </li>
  </ul>
</div>
      <div id="main">
  <div id="content">
<h1 class="title">Thinking in Text</h1>
<div id="table-of-contents">
<h2>Sisällysluettelo</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Thinking in Text   </a>
<ul>
<li><a href="#sec-1-1">Esittely</a>
<ul>
<li><a href="#sec-1-1-1">Alkusanat</a></li>
</ul>
</li>
<li><a href="#sec-1-2">Ensimmäinen yhteys</a>
<ul>
<li><a href="#sec-1-2-1">Hei Unix?</a></li>
</ul>
</li>
<li><a href="#sec-1-3">Merkinnöistä</a>
<ul>
<li><a href="#sec-1-3-1">Näppäinyhdistelmät</a>
<ul>
<li><a href="#sec-1-3-1-1">Ctrl</a></li>
<li><a href="#sec-1-3-1-2">Alt (tai Meta)</a></li>
<li><a href="#sec-1-3-1-3">Muut erikoisnäppäimet</a></li>
</ul>
</li>
<li><a href="#sec-1-3-2">Ohjelmien argumentit</a></li>
</ul>
</li>
<li><a href="#sec-1-4">Tiedostot, ja hakemistoissa seikkaileminen</a>
<ul>
<li><a href="#sec-1-4-1">Kuten Windowsissa</a>
<ul>
<li><a href="#sec-1-4-1-1"><code>ls</code></a></li>
</ul>
</li>
<li><a href="#sec-1-4-2">Kotihakemisto</a></li>
<li><a href="#sec-1-4-3">Oikeuksista</a></li>
<li><a href="#sec-1-4-4">Linkit</a></li>
</ul>
</li>
<li><a href="#sec-1-5">Joitain käytettyjä komentorivisovelluksia</a>
<ul>
<li><a href="#sec-1-5-1">Kaikki on legopalikoita</a></li>
<li><a href="#sec-1-5-2">Tärkeimmät palikat</a>
<ul>
<li><a href="#sec-1-5-2-1"><code>cat</code></a></li>
<li><a href="#sec-1-5-2-2"><code>wc</code></a></li>
<li><a href="#sec-1-5-2-3"><code>grep</code></a></li>
<li><a href="#sec-1-5-2-4"><code>sort</code></a></li>
<li><a href="#sec-1-5-2-5"><code>head</code> ja <code>tail</code></a></li>
<li><a href="#sec-1-5-2-6"><code>less</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-1-6">Man</a></li>
<li><a href="#sec-1-7">Virtojen ohjailua ja putket</a>
<ul>
<li><a href="#sec-1-7-1">Lähteet</a></li>
<li><a href="#sec-1-7-2">Muuntimet</a></li>
<li><a href="#sec-1-7-3">Altaat</a></li>
<li><a href="#sec-1-7-4">Uusia muuntimia</a>
<ul>
<li><a href="#sec-1-7-4-1"><code>tr</code></a></li>
<li><a href="#sec-1-7-4-2"><code>sed</code></a></li>
<li><a href="#sec-1-7-4-3"><code>awk</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-1-8">Komentorivi</a>
<ul>
<li><a href="#sec-1-8-1">Automaattitäydennys</a></li>
<li><a href="#sec-1-8-2">Haku historiasta</a></li>
<li><a href="#sec-1-8-3">Editoi riviä isommin</a></li>
<li><a href="#sec-1-8-4">Jatkoon</a></li>
</ul>
</li>
<li><a href="#sec-1-9">Pakkaus ja purkaminen</a>
<ul>
<li><a href="#sec-1-9-1">Tarballin purkaminen</a></li>
<li><a href="#sec-1-9-2">Pakkaaminen, eli tarballien luominen</a></li>
<li><a href="#sec-1-9-3">Entä zipit?</a></li>
</ul>
</li>
<li><a href="#sec-1-10">Haku päällä</a>
<ul>
<li><a href="#sec-1-10-1"><code>locate</code></a></li>
<li><a href="#sec-1-10-2"><code>find</code></a></li>
</ul>
</li>
<li><a href="#sec-1-11">Toistorakenteista</a>
<ul>
<li><a href="#sec-1-11-1">Kertaus jokereista</a></li>
<li><a href="#sec-1-11-2">Toistoa</a></li>
<li><a href="#sec-1-11-3"><code>seq</code></a></li>
</ul>
</li>
<li><a href="#sec-1-12">Työnohjaus komentorivillä</a>
<ul>
<li><a href="#sec-1-12-1">Suspensio</a></li>
<li><a href="#sec-1-12-2">Jobs</a></li>
<li><a href="#sec-1-12-3"><code>ps</code></a></li>
<li><a href="#sec-1-12-4">Kill</a></li>
</ul>
</li>
<li><a href="#sec-1-13">Screen</a>
<ul>
<li><a href="#sec-1-13-1">Screen moniajaa</a></li>
<li><a href="#sec-1-13-2">Screen ikkunoitsijana</a></li>
<li><a href="#sec-1-13-3">Muuta kivaa screenissä</a></li>
<li><a href="#sec-1-13-4">Yhteenveto</a></li>
</ul>
</li>
<li><a href="#sec-1-14">Editorit</a></li>
<li><a href="#sec-1-15">Nano</a></li>
<li><a href="#sec-1-16">Vi</a>
<ul>
<li><a href="#sec-1-16-1">Keskeiset komennot</a></li>
<li><a href="#sec-1-16-2">Vim</a></li>
<li><a href="#sec-1-16-3">Jatkoa varten</a></li>
</ul>
</li>
<li><a href="#sec-1-17">Kehittyneitä työkaluja</a>
<ul>
<li><a href="#sec-1-17-1"><code>diff</code></a></li>
<li><a href="#sec-1-17-2"><code>patch</code></a></li>
<li><a href="#sec-1-17-3"><code>make</code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-sec-1">

<div id="text-1" class="outline-text-2">

<p>
Unix-käytön perusteita ihmisille, jotka haluavat shell-yhteyksistään
<a href="http://irssi.org">irssiä</a> enemmän irti. Kirjoitin tämän joskus. Oletettavasti vuonna 2009
valmistui. Nauttikaa.
</p>
</div>

<div class="outline-3" id="outline-container-sec-1-1">
<h3 id="sec-1-1">Esittely</h3>
<div id="text-1-1" class="outline-text-3">
<dl class="org-dl">
<dt> Ville </dt><dd>Päähenkilömme, joka on juuri saanut shell-tunnuksen, eikä
oikein tiedä, mitä kaikkea sillä tehdä.
</dd>
<dt> Hemmo-Joachim </dt><dd>Aloitteleva noobi. Koodailee PHP:tä ja Pythonia
vapaa-ajallaan. Koulussa opetetaan Javaa.
</dd>
<dt> Matias </dt><dd>Unix-parta. Elää komentorivillä ja tekee kaikesta
hakkeritaidetta. Ei oikein pidä Windowsista.
</dd>
<dt> Karl </dt><dd>Koira. Saksanpaimen.
</dd>
</dl>

<p>
Esimerkkimme <b>Ville</b> kenties tarvitsee shell-käytön alkeita
päästäkseen irkkailemaan, ja hänpä myös kuuleman mukaan tarvitsee
vähän sivutilaa koulutöiden harjoittelemiseen. Saammepa nähdä, miten
hän suhtautuu uuteen palveluunsa.
</p>

<p>
<b>Hemmo-Joachim</b> on ehkä keltanokka, mutta into ja halu oppia on kova.
Hän on Ubuntu-saarnaajia, vaikka se <i>Seiska</i> onkin turvallisen
dualbootin päässä. Pelihimon lietsontaan hän kuulema Ubuntua käyttää.
Mehän tiedämmekin paremmin.
</p>

<p>
Ja pitäähän joukossa olla yksi taitajakin. Nimeksi olemme gurullemme
valinneet <b>Matiaksen</b>: hän tuntee tiensä mustavalkoisissa
terminaaliviidakoissa, muistaa ANSI-koodit unissaankin ja seuraa
linux-kernelin kehitystä viikkokirjein ja postituslistoin
aktiivisesti. Vapaa-ajallaan hän nauttii shakin pelaamisesta ja
väittelee finet-nyysseissä aina kun joku toinen sinne eksyy.
</p>
</div>

<div class="outline-4" id="outline-container-sec-1-1-1">
<h4 id="sec-1-1-1">Alkusanat</h4>
<div id="text-1-1-1" class="outline-text-4">
<p>
Tässä oppaassa keskitymme tarkastelemaan tekstipohjaisen komentorivin
erikoisuuksia, sekä joitain usein käytettyjä ohjelmia, joita voi etänä
käytellä mistä vain. Jos oikein malttaa lukea, vähintäänkin oppii
ymmärtämään, miksi se graafinen hiirellä klikkailu ei ole kaikkien
mielestä välttämätöntä päivittäisten askareiden hoitamiseksi. Valitsin
otsikoksi (tai työnimeksi, mikäli se siitä vaihtuu) juuri tuon nimen,
koska niin paljon tätä komentorivifilosofiaa kiteytyy kaiken tiedon
puhtaaseen tekstipresentaatioon. Mikään Word-muotoilu tai
OpenOffice-grafiikka ei korvaa sitä seikkaa, että puhtaana tekstinä
datasi on turvassa ja sitä voi käsitellä ennennäkemättömän monella eri
ohjelmalla.
</p>

<p>
Mikäli tämän jälkeen jää vielä kaipaamaan enemmän, eikä oppaasta ole
jäänyt etovaa makua suuhun, on Eric Raymondin <a href="http://www.catb.org/~esr/writings/taoup/">The Art of Unix
Programming</a> hyvä valinta jatkaa matkaansa kohti hakkerikulttuuria.
</p>

<p>
Oppaassa saatetaan vielä jatkossakin tehdä viittauksia <b>Jürgen von
Steinhugelin</b> kirjoihiin, josta pahoittelen etukäteen.
</p>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-sec-1-2">
<h3 id="sec-1-2">Ensimmäinen yhteys</h3>
<div id="text-1-2" class="outline-text-3">
<p>
Ensimmäistä yhteyttään ei yleensä jännitä samalla tavalla kuin toista
tai kolmatta yhteyttä. Ensimmäistä yhteyttä ottaessaan sitä lukee
hyvin mielin tutoriaaleja ja lähteitä, miten se oikein tehdään.
Toisella kerralla sitä uskoo omaan muistikapasiteettiinsa vähän
liikaa, ja sitten hermostuu, kun ei muistakaan seuraavaa askelta
ulkomuistista.
</p>

<dl class="org-dl">
<dt> Ville </dt><dd>Eli jos mä ymmärrän oikein, niin komennan <code>ssh
                   ville@viuhka.fi</code>?
</dd>
<dt> Matias </dt><dd>Polulle on monta reittiä. On valittava joskus
oikean ja väärän välillä. Ymmärräthän, mitä olet
komentamassa?
</dd>
<dt> Ville </dt><dd>Sähköpostissa on samanlainen skeema. Tunnus on
                   <code>ville</code> ja palvelin on <code>viuhka.fi</code>.

<p>
Puttyssä sitten vastaavasti tunnus ja palvelin
laitetaan haluttuihin kohtiin.
</p>
</dd>
</dl>

<p>
Tietenkään, se ei ole <code>ssh</code> mitä ihmiset jännittävät. Se on vain
väline päästä käsiksi Unix-shelliin. Shell, tuo komentorivien valtias.
Shell on ohjelma, joka tavallisesti ottaa vastaan tekstiä käyttäjältä,
ja suorittaa muita ohjelmia sitten annetun syötteen mukaan. Shell on
ensimmäisten päätetietokoneiden myötä syntynyt <i>batch</i>-henkinen tapa
vuorovaikuttaa tietokoneiden kanssa.
</p>

<dl class="org-dl">
<dt> Ville </dt><dd>Ööh, eli mikä toi <i>bäts</i> on?
</dd>
<dt> Matias </dt><dd>Annat syötteen koneelle kokonaisuudessaan, ja kone
ajaa sen. Sen jälkeen voit komentaa lisää. Nykyisin
on enemmän vuorovaikutteisista ohjelmista kyse,
jossa jokainen tehtävä suunnitellaan yhdessä koneen
ja käyttäjän kanssa, ja sitten lopuksi kone
suorittaa sen.
</dd>
<dt> Ville </dt><dd>Aha. Eikö se ole vähän kankeeta sitten?
</dd>
<dt> Matias </dt><dd>Monissa hommissa ei tarvitse interaktiivisuutta.
Niissä, joissa tarvitaan, on sitten interaktiiviset
valikot sun muut.
</dd>
</dl>

<p>
Kaikilla käytännön tasoilla tarkasteltuna <code>ssh</code>-asiakasohjelmalla
(esimerkiksi Windows-ympäristössä PuTTy ja OpenSSH
Linux/Unix-maailmoissa; komentoriviltä ajettava <code>ssh</code>) yhteyden
ottaminen Unix-palvelimeen on samanlaista etäkäyttöä kuin vaikka
Windowsien etätyöpöydän ajaminen. Onneksi puhtaasta tekstistä
koostuvien konsoliohjelmien ajaminen on sujuvaa hitaammallakin
nettiyhteydellä, sekä rajoitetummistakin ympäristöistä, kuten
älypuhelimista onnistuu etäkäyttö.
</p>

<p>
Jos olet itse Linux-ympäristössä, kuten Ubuntussa, ei sinun tietenkään
tarvitse ottaa ssh-yhteyksiä minnekään, vaan voit avata Terminaalin
tai vastaavan, jolla voit tutustua komentorivin saloihin yhtä hyvin
kuin etänäkin.
</p>
</div>

<div class="outline-4" id="outline-container-sec-1-2-1">
<h4 id="sec-1-2-1">Hei Unix?</h4>
<div id="text-1-2-1" class="outline-text-4">
<p>
Mainittakoon, että puhumme tässä oppaassa Unixeista, vaikka oikeasti
Linux ei edes ole tarkalleen ottaen Unix. Siis yksinkertaistetusti
<i>Linux on yksi Unix-variantti</i>. Koska valtaosa, ellei kaikki, mitä
tässä oppaassa opimme, toimii Linuxien lisäksi Unixeissa, niin puhun
yleisemmällä tasolla Unix-käytöstä.
</p>

<dl class="org-dl">
<dt> Ville </dt><dd><i>I'm in!</i>
</dd>
<dt> Matias </dt><dd>Hieno homma.
</dd>
<dt> Ville </dt><dd>Mitä tässä voi nyt sitten tehdä? Kirjoittaa tekstiä
ja odotella kun kone vastaa?
</dd>
<dt> Matias </dt><dd>Ohjelma, jota siinä "ajat" tällä hetkellä, on se
kuuluisa shelli sitten. Todennäköisimmin shell
nimeltä <code>bash</code>. Joskus kirjallisuudessa puhutaan
kuoriohjelmista, mutta on se aika toivoton
suomennos.
</dd>
</dl>

<p>
Shell-ohjelmia on monia, joista <code>bash</code> on ylivoimaisesti suosituin
tänä päivänä. Joskus saattaa nähdä myös vanhempaa <code>csh</code>-ohjelmaa
käytössä. Peruskäytössä jokainen toimii yhtä hyvin, ja erot eri
shellien välillä tulevat ilmi vasta monimutkaisempia skriptejä
kirjoitellessa. Nykyisin kaksi suositeltavinta shelliä kaikkeen
käyttöön ovat <code>bash</code> ja <code>zsh</code>, joita ylläpidetään ahkerasti. Tässä
vaiheessa ei tarvitse tietää muuta kuin se, että shell-ohjelma on oma
sovelluksensa, irti käyttöjärjestelmän ytimestä. Tiedät sitten sanoa,
että se on <code>bash</code> joka kenkkuilee, eikä linux.
</p>

<dl class="org-dl">
<dt> Matias </dt><dd>Maistelepa komentorivin taikaa. Komennapa vaikka:

<pre class="example">
echo Hei Unix!
</pre>
</dd>

<dt> Ville </dt><dd>Kyllä minä nyt <code>echo</code>:n tiedän. Ei sillä ole kyllä
paljoa käyttöä. Tuossahan minä näen sen tekstin
ilman enterin painamistakin!
</dd>
<dt> Matias </dt><dd>Echolla on käyttönsä esimerkiksi skriptatessa.
</dd>
<dt> Ville </dt><dd>Pitääkös minun osata skriptausta? PHP ei ole vahvin
lajini…
</dd>
<dt> Matias </dt><dd>Kun osaat luovia komentorivillä, osaat samalla
skriptata. Voithan ottaa tästä vähän vaativamman
esimerkin:

<pre class="example">
echo Hei $USER
</pre>
</dd>

<dt> Ville </dt><dd>Se näyttää keksivän nimeni jostain. On se epeli tuo
                   <code>echo</code>.
</dd>
<dt> Matias </dt><dd>Paitsi että <code>echo</code> ei ole se fiksu osapuoli.
Shellisi tekee muunnoksen kutsuvaiheessa, ja echo
näkee vain tekstin "<code>Hei ville</code>" tulostettavaksi.
</dd>
<dt> Ville </dt><dd>Vai silleen.
</dd>
<dt> Matias </dt><dd>Katsos, siten ei jokaisen pikkuohjelman tarvitse
itse ratkaista tuota <code>$USER</code>:in merkitystä, vaan
riittää että yksi ohjelma, shell, hoitaa sen.
</dd>
</dl>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-sec-1-3">
<h3 id="sec-1-3">Merkinnöistä</h3>
<div id="text-1-3" class="outline-text-3">
<p>
Ennen kuin voimme kunnolla alkaa matkaamme kohti Unix-herruutta, pitää
meidän tietää, mistä puhutaan. Ja millä keinoin. Tässä oppaassa
käytämme luultavasti melko epäyhtenäistä merkintätapaa erilaisille
asioille, mutta käydään esimerkkejä tässä parhaamme mukaan.
</p>
</div>

<div class="outline-4" id="outline-container-sec-1-3-1">
<h4 id="sec-1-3-1">Näppäinyhdistelmät</h4>
<div id="text-1-3-1" class="outline-text-4">
<p>
Unix-maailma on täynnä näppäinyhdistelmiä: hyvin harva
komentoriviohjelma edes tietää hiirestä. Monet ohjelmista ovat
alkujaan kauan ennen kuin ohjainrasiat yleistyivät. Ja toisaalta
tekstin kanssa peuhatessa on muutenkin hiirelle vähän käyttöä.
</p>

<p>
Kun esittelemme näppäinkomentoja ja -yhdistelmiä, on käytössä useampi
erilainen merkintätapa. Syyksi valitsen tähän sen, että eri
ohjelmistot ovat luoneet omia, vakiintuneita ilmaisutapoja
merkitsemään näppäinyhdistelmiä. Koska ne eivät ole mitenkään vaikeita
omaksua, niin käytän itse niitä sopivissa tilanteissa eri tavoin.
Näistä merkinnöistä voi sen verran sanoa, että kulmasulkeisiin
asetettava on Vi(m)-käyttäjien keskuudessa suosittu tapa, ja
Emacs-puoli sitten suosii sulkeitta esitettävää muotoa.
</p>
</div>

<div class="outline-5" id="outline-container-sec-1-3-1-1">
<h5 id="sec-1-3-1-1">Ctrl</h5>
<div id="text-1-3-1-1" class="outline-text-5">
<p>
Tämä ohjausnäppäin kirjoitetaan tässä oppaassa jollain näistä tavoista:
</p>

<pre class="example">
&lt;C-h&gt;
C-h
</pre>

<p>
Esimerkissä ilmaistiin siis näppäinkomennon <code>Ctrl-h</code> painaminen.
</p>
</div>
</div>
<div class="outline-5" id="outline-container-sec-1-3-1-2">
<h5 id="sec-1-3-1-2">Alt (tai Meta)</h5>
<div id="text-1-3-1-2" class="outline-text-5">
<p>
Vanhoissa tietokoneissa ei välttämättä ollut Alt-nimistä painiketta, vaan
puhuttiin <b>jostain</b> metasta, joka oli välillä konekohtainen. Tämä
metanäppäin liittyy Esciin erityisellä tavalla:
</p>

<pre class="example">
&lt;M-h&gt;
M-h
&lt;Esc&gt; h
ESC h
</pre>

<p>
Ovat kaikki samaa tarkoittavaa. Ja erityisesti jos käytät jotain
ssh-ohjelmaa, jonka kanssa Alt-yhdistelmät eivät tunnu menevän
perille, niin kokeile painaa ensin Esciä, sitten vapautat sen ja
painat lopuksi muuta yhdistelmää.
</p>
</div>
</div>
<div class="outline-5" id="outline-container-sec-1-3-1-3">
<h5 id="sec-1-3-1-3">Muut erikoisnäppäimet</h5>
<div id="text-1-3-1-3" class="outline-text-5">
<p>
Muissa tapauksissa pyrin käyttämään Vim-dokumentaatiossa suosittua tapaa
esittää kaikki erikoiset merkinnät kulmasulkeissa, siis esimerkiksi
seuraavanlaisia merkintöjä:
</p>

<pre class="example">
&lt;CR&gt;
&lt;Tab&gt;
&lt;F1&gt;
&lt;Up&gt;
</pre>

<p>
<code>CR</code> on Enter, eli <i>Carriage Return</i>. Siitä en tingi. Muut
esimerkeistä ovat toivottavasti tuttuja.
</p>
</div>
</div>
</div>
<div class="outline-4" id="outline-container-sec-1-3-2">
<h4 id="sec-1-3-2">Ohjelmien argumentit</h4>
<div id="text-1-3-2" class="outline-text-4">
<p>
Komentoriviltä käynnistetään ohjelmat tyypillisesti kirjoittamalla
ohjelman nimi kehotteeseen ja painetaan enteriä. Ohjelmille on hyvin
tavallista ottaa vastaan niinsanottuja argumentteja eli parametrejä.
Parametrejä on karkeasti luokiteltaessa kahdenlaista sorttia:
</p>

<dl class="org-dl">
<dt> optiot </dt><dd>    Optiot ovat asetuksia, joilla ohjelman toimintaa säädetään yhden
suorituskerran ajaksi. Ne annetaan tyypillisesti ensimmäisenä ohjelmanimen
jälkeen, ja voivat olla joko yhden viivan ja yhden merkin mittaisia (ns.
<b>short option</b>: esimerkki <code>-a</code>) tai kahden viivan kanssa olevia pidempiä
sanoja (<b>long option</b>: esimerkki <code>--add</code>).
</dd>
<dt> tiedostonimet </dt><dd>    Useimmat ohjelmat ottavat vastaan tiedostoja, joita ne käsittelevät. On
tavallista antaa tiedostonimet lopuksi. Useimmat ohjelmista ottavat
enemmän kuin yhden nimen kerrallaan.
</dd>
</dl>

<p>
Otetaan ensin esimerkki:
</p>

<pre class="example">
$ ls -l hak
</pre>

<p>
Ensimmäisenä on merkintäkäytäntönä käyttää dollarimerkkiä, koska
<code>sh</code>-sukuiset shellit, siis valtaosa, käyttävät sitä kehotteessaan.
Sitä ei kirjoiteta itse näkyville, ja se indikoi käyttäjän itse
kirjoittamaa tekstiä. Tätä seuraa sitten yleensä ohjelman antamaa
tulostetta. Komentoriviltä käytettäessä näet itse vastaavanlaista,
joten tämän ei pitäisi olla vaikeaselkoista.
</p>

<p>
Esimerkkimme komennossa on siten kolme osaa, esimerkillisesti yksi
kutakin: ohjelman nimi <code>ls</code>, ja ohjelmalle on annettu kaksi
argumenttia: optio <code>-l</code> ja tiedostonimi (hakemistotkin ovat
tiedostoja) <code>hak</code>.
</p>

<p>
Yleisempi esimerkki, joka valottaa kahta muuta merkintätapaa:
</p>

<pre class="example">
$ ohjelma [-a|-b] [-c] [FILE]...
</pre>

<p>
Hakasulkeet <code>[]</code> ilmaisevat, että jokin asetus ei ole pakollinen. Sen
voi siis jättää kokonaan pois. Putkimerkki <code>|</code> ilmaisee, että
annetuista asetuksista vain toisen saa kerralla antaa. Kolme pistettä
FILE-argumentin jälkeen tarkoittaa, että voit halutessasi antaa
enemmänkin tiedostonimiä. Koska <code>FILE</code> on hakasulkeissa, ei ole pakko
antaa yhtäkään tiedostonimeä. Tämän esimerkin ohjelmalle ei ole
kokonaisuudessaan pakko antaa yhtään mitään, koska kaikki on
hakasulkeissa. Kertauksen vuoksi:
</p>

<dl class="org-dl">
<dt> <code>ohjelma FILE</code> </dt><dd>    ottaa tasan yhden tiedoston
</dd>
<dt> <code>ohjelma [FILE]</code> </dt><dd>    ottaa vastaan 0-1 tiedostoa
</dd>
<dt> <code>ohjelma FILE...</code> </dt><dd>    ottaa yhden tai useamman tiedoston
</dd>
<dt> <code>ohjelma [FILE]...</code> </dt><dd>    ottaa mielivaltaisen määrän tiedostoja
</dd>
</dl>

<p>
Vielä yksi huomio: useamman lyhyen asetuksen voi halutessaan yhdistää
yhden viivan taakse. Seuraavat kaksi komentoa tekevät saman asian:
</p>

<pre class="example">
$ ls -l -a -h
$ ls -lah
</pre>

<p>
Saatamme palata argumenttien semantiikkaan myöhemmin oppaassa, mutta
tässäkin taisi olla jo tuhti annos ah niin vaikeata kielioppia.
</p>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-sec-1-4">
<h3 id="sec-1-4">Tiedostot, ja hakemistoissa seikkaileminen</h3>
<div id="text-1-4" class="outline-text-3">
<dl class="org-dl">
<dt> Matias </dt><dd>Ei kai minun tarvitse opettaa teille
hakemistorakenteiden käsitettä uudestaan? Unixeissa
on samanlainen hakemistorakenne kuin Dosissa ja
Windowseissa:

<p>
Hakemistot sisältävät
</p>

<ul class="org-ul">
<li>tiedostoja
</li>
<li>tai muita hakemistoja.
</li>
</ul>
<p>
Tämä oli lyhyt, ja toivottavasti täydellinen, (samalla
elegantin rekursiivinen) määritelmä aiheeseen.
</p>
</dd>
<dt> Ville </dt><dd>Joo, samanlainen pitäisi olla, mutta missä on <code>C:</code>
ja muut asemat?
</dd>
<dt> Matias </dt><dd>Sellaisia ei ole. Kaikki on yhdessä
                   <i>tiedostojärjestelmässä</i>, ja näin on hyvä.
</dd>
<dt> Hemmo-Joachim </dt><dd>Ei ole Ceetä tai Äffää, on vain "päähakemisto" ja
usb-tikku.
</dd>
<dt> Matias </dt><dd>Onhan Windowseissakin pyritty siirtymään enemmän
"Omat tiedostot" -ajatteluun. Pyörimme samalla
tavalla pienissä kuvioissa, joten tällä ei ole
merkitystä.
</dd>
<dt> Ville </dt><dd>No katsellaan sitten se käytäntö.
</dd>
</dl>
</div>

<div class="outline-4" id="outline-container-sec-1-4-1">
<h4 id="sec-1-4-1">Kuten Windowsissa</h4>
<div id="text-1-4-1" class="outline-text-4">
<dl class="org-dl">
<dt> Matias </dt><dd>Tärkein komento, mistä voimme alkaa, on <code>pwd</code>:
"print working directory".
</dd>
<dt> Ville </dt><dd>Englannin seiskani sanoo, että se tulostaisi
nykyisen hakemiston…?
</dd>
<dt> Hemmo-Joachim </dt><dd>Aivan oikein.
</dd>
<dt> Matias </dt><dd>Ja sen käyttö on niin helppoa kuin voi olla:

<pre class="example">
$ pwd
/home/matias
</pre>
</dd>

<dt> Hemmo-Joachim </dt><dd>Mulla näkyy muuten toi aina tossa promptissa, ei
tarvi tätä komentoa käytellä.
</dd>
<dt> Matias </dt><dd>Tämä onkin enemmän koneita kuin ihmisiä varten.
Onpa tällä käyttönsä tietyissä tilanteissa.
</dd>
<dt> Ville </dt><dd>Siis tarvinko minä tätä vai en?
</dd>
<dt> Matias </dt><dd>Onpa tyhmä kysymys. Jos et muuten näe mistään,
missä olet, niin sitten tarvitset.
</dd>

<dt> Matias </dt><dd>Seuraavaksi jotain mielekkäämpää. Oletetaan, että
meillä on seuraavanlainen hakemistorakenne:

<pre class="example">
/home/matias
        |-- autot
        |   |-- bmw
        |   `-- fiat
        `-- kissat
</pre>

<p>
Kaipa tuosta tekstistä saa selvää.
</p>
</dd>
<dt> Ville </dt><dd>No ei tämä kai ollutkaan mikään taidekurssi…
</dd>
<dt> Matias </dt><dd>No niin. Jos leikimme, että olemme tuossa
hakemistossa <code>.</code> ylimmäisenä. Siirrymme muihin
hakemistoihin komennolla <code>cd</code>:

<pre class="example">
$ pwd
/home/matias
$ cd autot
$ pwd
/home/matias/autot
</pre>
</dd>

<dt> Hemmo-Joachim </dt><dd>Vanhaa juttua kyllä.
</dd>
<dt> Ville </dt><dd>Harvinaisen selvä juttu.
</dd>
<dt> Matias </dt><dd>Mutta olikos selvillä, miten palataan ylöspäin
hakemistoissa? Se on tämä erikoishakemisto,
kaksipisteinen <code>..</code>:

<pre class="example">
$ cd ..
$ pwd
/home/matias
</pre>

<p>
Jos nyt oletimme, että pysymme kokoajan siinä, mihin
edellisessä kokeessa jäätiin.
</p>

<p>
Samalla tavalla voimme ketjuttaa useita hakemistoja samaan
kutsuun. Jos haluan mennä tutkimaan Fiat-fileitä, niin tämä
oneliner hoitaisi homman:
</p>

<pre class="example">
$ cd autot/fiat
</pre>

<p>
Ja voi palata ylös samalla tavalla ketjuttamalla:
</p>

<pre class="example">
$ cd ../..
$ pwd
/home/matias
</pre>
</dd>

<dt> Ville </dt><dd>Eli toi <code>..</code> on vähän kuin paluulinkki takaisin?
</dd>
<dt> Matias </dt><dd>No se riippuu siitä, mistä tulet. Se on tarkalleen
ottaen ylöspäin (tai vasemmalle, jos polku on
kirjoitettu auki muodossa <code>/hake/hake/hake/</code>.
</dd>
<dt> Ville </dt><dd>Onkos sitten erikseen joku paluujuttu niinku
selaimissa on?
</dd>
<dt> Matias </dt><dd>On olemassa kiva lisä, joka tekee mainitsemasi
asian:

<pre class="example">
$ cd autot/fiat
$ cd ../bmw
$ cd -
$ pwd
/home/matias/autot/fiat
</pre>
</dd>

<dt> Ville </dt><dd>No johan on!
</dd>
<dt> Hemmo-Joachim </dt><dd>No johan oikeasti!
</dd>
<dt> Matias </dt><dd>Ja jos teillä on huonosti nimetty hakemisto, siis
nimeltänsä <code>-</code>, niin sinne voi siirtyä antamalla
hakemistopolun hieman kikkailemalla:

<pre class="example">
$ cd ./-
</pre>
</dd>

<dt> Hemmo-Joachim </dt><dd>No niin.
</dd>
</dl>
</div>

<div class="outline-5" id="outline-container-sec-1-4-1-1">
<h5 id="sec-1-4-1-1"><code>ls</code></h5>
<div id="text-1-4-1-1" class="outline-text-5">
<dl class="org-dl">
<dt> Matias </dt><dd>Eiköhän siirrytä nyt jo noihin tiedostoihin. Siihen
on vain yksi keskeinen ohjelma: <code>ls</code>:

<pre class="example">
$ ls autot/bmw
penkit    ratti
</pre>
</dd>

<dt> Hemmo-Joachim </dt><dd>On myös mahdollista käyttää dossin <code>dir</code>-komentoa
täällä!
</dd>
<dt> Matias </dt><dd>No se on enemmän tätä <code>ls</code>-komentoa vastaava kuin
alkuperäistä <code>dir</code>:iä.
</dd>
<dt> Ville </dt><dd>List – <code>ls</code>?
</dd>
<dt> Matias </dt><dd>Niin, tällä siis katsellaan hakemiston sisältöä.
Jos olette onnekkaita, niin <code>ls</code> antaa teille
oikein värien kanssa tiiviin listauksen hakemiston
sisällöstä.
</dd>
<dt> Ville </dt><dd>Tämä selvä.
</dd>
<dt> Matias </dt><dd><code>ls</code> ei tarvitse hakemistoa. Jos jätätte sen pois,
kuten tavallisimmin tehdään, niin se listaa
tämänhetkisen hakemiston sisällön. Sitä käytetään
eniten:

<pre class="example">
$ cd autot/bmw
$ ls
penkit    ratti
</pre>
</dd>

<dt> Matias </dt><dd>Ja <code>ls</code> tekee paljon muutakin… käydään vain vähän
pintaa raapaisemassa tässä vaiheessa. Oletetaan,
että meillä on tämmöinen hakemisto, jossa on
tiedostoja:

<pre class="example">
$ ls
burgeri.txt  kalastaja  karvinen  siamilainen
</pre>

<p>
Voisimme halutessamme katsoa <code>ls</code>:n avulla vähän
syventävämpiä tietoja näistä tiedostoista. Sitä
varten on optio <code>-l</code>, eli <b>long</b>:
</p>

<pre class="example">
$ ls -l
total 16
-rw-r--r-- 1 matias matias  412 Jul 15 17:07 burgeri.txt
-rw-r--r-- 1 matias matias  542 Jul 15 17:03 kalastaja
-rw-r--r-- 1 matias matias 2354 Jul 15 17:18 karvinen
-rw-r--r-- 1 matias matias  423 Jul 15 17:03 siamilainen
</pre>
</dd>

<dt> Hemmo-Joachim </dt><dd>Tossa on aika paljon tietoja.
</dd>
<dt> Ville </dt><dd>Niin, mitä kaikkea tuossa sanotaan?
</dd>
<dt> Matias </dt><dd>Tätähän voi vähän muutella, mutta tässä
listauksessa on järjestyksessä seuraavat tiedot:

<ol class="org-ol">
<li><code>-rw-r--r--</code>: oikeudet (tutkimme niitä vähän myöhemmin)
</li>
<li>1: kovien linkkien lukumäärä (ehkä maininta myöhemmin)
</li>
<li>Ensimmäinen <code>matias</code>: käyttäjä, kenen tämä tiedosto on
</li>
<li>Toinen <code>matias</code>: ryhmä, jolle tämä tiedosto kuuluu
</li>
<li><code>412</code>: koko tavuina
</li>
<li><code>Jul 15 17:07</code>: päiväys ja kellonaika, jolloin
on viimeksi muutettu
</li>
<li><code>burgeri.txt</code>: tiedoston nimi
</li>
</ol>
<p>
Tässä voi olla itse asiassa enemmän tai vähemmän tietoja,
riippuen vähän, minkälaisesta tiedostosta on kyse. 
</p>
</dd>
<dt> Ville </dt><dd>Aika omituiset tiedot. Koko on aika huonosti
luettavissa tavuista.
</dd>
<dt> Matias </dt><dd>Eniten käytetty optio <code>-l</code>:n lisäksi on <code>-h</code>, eli
<b>human readable</b>. Se muuntaa tiedostojen koot aina
sopivaksi yksiköksi:

<pre class="example">
$ ls -lh
total 16K
-rw-r--r-- 1 matias matias  412 Jul 15 17:07 burgeri.txt
-rw-r--r-- 1 matias matias  542 Jul 15 17:03 kalastaja
-rw-r--r-- 1 matias matias 2,3K Jul 15 17:18 karvinen
-rw-r--r-- 1 matias matias  423 Jul 15 17:03 siamilainen
</pre>
</dd>

<dt> Ville </dt><dd>No nyt alkaa näyttää hyvältä.
</dd>
<dt> Matias </dt><dd>Pikkukikkailua voi <code>ls</code>:llä tehdä loputtomiin.
Flagin <code>-t</code> avulla tiedostot lajitellaan muutosajan
perusteella. Oletushan on aakkosjärjestys. <code>ls -t</code>
antaisi esimerkissämme tiedoston <code>karvinen</code>
ensimmäisenä, koska sitä on muutettu viimeisimpänä.
</dd>
<dt> Hemmo-Joachim </dt><dd>Jotain uuttakin oppii!
</dd>
<dt> Matias </dt><dd><code>ls</code> ottaa vastaan argumentteinaan sekä tiedostoja
että hakemistoja (tyhjän lisäksi). Se listaa
silloin vain ne tiedostot, jotka käyttäjä on sille
antanut. Kuulostaa vähän hupsulta?
</dd>
<dt> Ville </dt><dd>Kyllä se joo. Jos käyttäjä tietää jo niitä nimiä,
niin mitä siitä kostuu. No tietysti jos haluaa
kokoja katsella…
</dd>
<dt> Matias </dt><dd>Erityisesti jos annamme shellin auttaa vähän. Shell
osaa hakea tiedostonimiä ns. <b>wildcardien</b> tai
suomalaisittain jokerimerkkien avulla. Idea on
toivottavasti selvä Dos-ajoilta. Ja jos
olettaisimme, että tiedostoja on tuhatkaupalla.
Kaikkea ei pysty käsittämään pieni ihminen
kerralla.

<p>
Annanpas ihan käyttötapauksia esimerkkeinä, jospa
ymmärrätte tai muistatte paremmin, mistä on kyse.
Tämmöinen oli meidän hakemistomme sisältö:
</p>

<pre class="example">
$ ls
burgeri.txt  kalastaja  karvinen  siamilainen
</pre>

<p>
Kaikki tekstitiedostot, tai ainakin kaikki tiedostot, jotka on
nimetty <code>.txt</code>-päätteisiksi:
</p>

<pre class="example">
$ ls *.txt
burgeri.txt
</pre>

<p>
Pienellä kirjaimella <code>k</code> alkavat tiedostonimet:
</p>

<pre class="example">
$ ls k*
kalastaja  karvinen
</pre>

<p>
Nenniläiset:
</p>

<pre class="example">
$ ls *nen
karvinen  siamilainen
</pre>

<p>
Ja yhdistelmänä tiedostot, jotka alkavat pienellä koolla ja
päättyvät <code>nen</code>-päätteeseen:
</p>

<pre class="example">
$ ls k*nen
karvinen
</pre>
</dd>

<dt> Ville </dt><dd>Dos-ajoilta muistan, että tähti (eli asteriski, eli
<code>*</code>) vastaa yhtä tai useampaa merkkiä, ja
kysymysmerkki <code>?</code> yhtä merkkiä.
</dd>
<dt> Matias </dt><dd>Kyllä ne vähän samaa ovat, mutta on pieni ero.
Tähti vastaa myös nollaa merkkiä, mikä voi
kuulostaa ihmeelliseltä:

<pre class="example">
$ ls karvinen*
karvinen
</pre>
</dd>
</dl>

<p>
Summariikkina:
</p>

<table frame="hsides" rules="groups" cellpadding="6" cellspacing="0" border="2">


<colgroup>
<col class="left"></col>

<col class="left"></col>
</colgroup>
<thead>
<tr>
<th class="left" scope="col">Jokerimerkki</th>
<th class="left" scope="col">Vastaa</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>*</code></td>
<td class="left">0 tai enemmän merkkejä</td>
</tr>

<tr>
<td class="left"><code>?</code></td>
<td class="left">1 merkkiä</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="outline-4" id="outline-container-sec-1-4-2">
<h4 id="sec-1-4-2">Kotihakemisto</h4>
<div id="text-1-4-2" class="outline-text-4">
<dl class="org-dl">
<dt> Matias </dt><dd>Sitten vähän lisää hakemistoista, nimittäin
kotihakemiston käsite. Nykyisin on tämä helpompaa
selittää, kun koti-Windowsit ovat päässeet samalle
tasolle. Samalla tavalla kuin teillä on
Windowseissa <code>C:\Users\</code> -polun takana omat
tavaranne, joihin muut eivät pääse käsiksi, niin
Unixeissa on vastaava hakemisto <code>/home/</code>.
</dd>
<dt> Ville </dt><dd>En nyt käsitä…
</dd>
<dt> Hemmo-Joachim </dt><dd>Jokaisella on se oma "Omat tiedostot" -hakemisto,
johon ei yleensä pääse katselemaan muut kuin sen
hakemiston omistaja itse.
</dd>
<dt> Ville </dt><dd>Niin.
</dd>
<dt> Matias </dt><dd>Ja nyt Unixeissa on myös jokaisella oma kotisoppi,
yleensä sijaitsee hakemistossa <code>/home/&lt;käyttäjä&gt;/</code>.

<p>
Esimerkiksi minulla on systeemeissäni <code>/home/matias/</code>. Se on
kokonaan minun aluettani, johon säilötään omat asetustiedostot
ja datat.
</p>
</dd>
<dt> Ville </dt><dd>Mistä sen tietää, jos on semmoinen hakemisto?
</dd>
<dt> Matias </dt><dd>Sen osaa aavistaa. Jos ei ole, niin yleensä mikään
ei toimi kunnolla.
</dd>
<dt> Matias </dt><dd>Ja nyt shellissä pyöriessäsi kotihakemisto on
syystäkin varsin merkityksellinen paikka. Isoissa
koneissa et yksinkertaisesti pääse tekemään muualla
mitään kuin omassa hakemistossasi.

<p>
Siksi sille on annettu näppärä lyhenne kaikissa shelleissä:
<code>~</code>, eli <i>tilde</i> tai matomerkki.
</p>
</dd>
<dt> Ville </dt><dd>Miten sitä lyhennettä pääsee käyttämään?
</dd>
<dt> Hemmo-Joachim </dt><dd>No kaikkialla, missä voi antaa hakemistopolkua, voi
käyttää tätä tildeä merkkaamaan omaa
kotihakemistoa:

<pre class="example">
$ pwd
/home/hemmo/aybabtu
$ cd ~
$ pwd
/home/hemmo
</pre>
</dd>

<dt> Matias </dt><dd>Näin voi tehdä. Huomautettakoon, että pelkkä <code>cd</code>
tekee saman mitä <code>cd ~</code>. Tilden käyttö on hyvin
oleellinen osa kotona luoviessaan. Tämmöinen käytös
on hyvin yleistä, kun haluan vaihtaa nopeasti eri
hakemistoista toisiin:

<pre class="example">
$ pwd
/home/matias/autot/fiat
$ cd ~/kissat
$ pwd
/home/matias/kissat
</pre>

<p>
Se vain on nopeaa ja selkeätä käyttää tildeä ikään kuin
päähakemistona, josta koti alkaa.
</p>
</dd>
</dl>
</div>
</div>
<div class="outline-4" id="outline-container-sec-1-4-3">
<h4 id="sec-1-4-3">Oikeuksista</h4>
<div id="text-1-4-3" class="outline-text-4">
<p>
Ja pari sanaa oikeuksista. Kotihakemistosta keskusteltaessamme
mainitsimme, että muut eivät välttämättä pääse katselemaan saati
kirjoittamaan omia tiedostojamme uusiksi. Unixin
tiedosto-oikeusjärjestelmä on vanha ja hyvin simppeli, mikä tekee
siitä ainakin helposti opittavan, jos ei kovinkaan nykyaikaisen.
</p>

<p>
Tämä malli on kuitenkin äärimmäisen helppo ymmärtää:
</p>

<ul class="org-ul">
<li>Kukin käyttäjä voi kuulua eri ryhmiin.
</li>
<li>Tiedostolla tai hakemistolla on aina yksi omistaja ja yksi ryhmä,
johon se kuuluu.
</li>
<li>Tiedostolla tai hakemistolla on kolme erilaista asetusta kullekin
käyttäjäkunnalle: omistaja, ryhmä (tiedoston ryhmä), muut (kuin
omistaja tai kyseinen ryhmä).
</li>
</ul>

<p>
Tarkastellaan aiemmin nähtyä esimerkkiä. Tässä on <code>ls -l</code> -syötettä
tiedostosta <code>karvinen</code>:
</p>

<pre class="example">
-rw-r--r-- 1 matias matias 2354 Jul 15 17:18 karvinen
  3.           1.     2.
</pre>

<p>
Numeroidut kohdat:
</p>

<ol class="org-ol">
<li>Tiedoston omistaja, <code>matias</code>.
</li>
<li>Tiedoston ryhmä, myös nimetty <code>matias</code>. Sattumalta tässä systeemissä kukin
käyttäjä saa myös oman nimikkoryhmänsä käyttäjäluonnin yhteydessä. Yleinen
vaihtoehto on myös <code>users</code>, tai muuta.
</li>
<li>Tässä näkyvät tiedoston oikeudet. Tämä kymmenmerkkinen rimpsu on helposti
luettavassa muodossa oleva katsaus oikeuksiin. Jos oikeutta ei ole, niin
annetaan viiva. Muuten siinä näkyy lyhenne. Käydään nämä läpi:

<ol class="org-ol">
<li>Ei oikeastaan oikeusmerkki, vaan ilmaisee, onko kyseessä tiedosto (<code>-</code>)
vai hakemisto (<code>d</code>). Voi olla joitain muitakin merkkejä, jos kyseessä on
vielä erikoisempi tiedosto.
</li>
<li>Omistajan lukuoikeus (<code>r</code>: read)
</li>
<li>Omistajan kirjoitusoikeus (<code>w</code>: write)
</li>
<li>Omistajan suoritusoikeus (<code>x</code>: execute).
</li>
<li>Ryhmän lukuoikeus
</li>
<li>Ryhmän kirjoitusoikeus
</li>
<li>Ryhmän suoritusoikeus 
</li>
<li>Muiden lukuoikeus
</li>
<li>Muiden kirjoitusoikeus
</li>
<li>Muiden suoritusoikeus 
</li>
</ol>
</li>
</ol>

<p>
Lukuoikeus on oltava, jotta tiedoston sisällön näkee. Kirjoitusoikeus
on aika ilmeinen. Suoritusoikeus tarkoittaa sitä, että tiedoston voi
ajaa kuin ohjelman. Hakemiston tapauksessa tarkoittaa, että sisään voi
mennä.
</p>

<p>
Tuota kymmenen merkin sarjaa on helppoa lukea kolmen palasissa, ja
unohtaa ensimmäinen merkki. Jos tiedoston ryhmäoikeuksiin on merkitty
<code>rw-</code>, niin kaikki ne käyttäjät, jotka kuuluvat samaan ryhmään kuin
tiedosto, voivat kirjoittaa ja lukea näitä tiedostoja.
</p>
</div>
</div>
<div class="outline-4" id="outline-container-sec-1-4-4">
<h4 id="sec-1-4-4">Linkit</h4>
<div id="text-1-4-4" class="outline-text-4">
<dl class="org-dl">
<dt> Matias </dt><dd>Lyhyt maininta linkeistä, joita on Unixeissa
kahdenlaista. On kovia ja pehmeitä linkkejä.
Pehmeät linkit, tai symboliset linkit, ovat kuin
Windowsissa pikakuvakkeet. Mutta vähän
monipuolisempia.
</dd>
<dt> Ville </dt><dd>Ai että voi työpöydälle laittaa linkin niin siihen
voi mennä suoraan?
</dd>
<dt> Matias </dt><dd>Eh. Nämä linkit käyttäytyvät kuin muut tiedostot,
ja niitä voi tehdä minne tahansa. Hyvin näppärä
tapa saada samat tiedostot näkymään eri paikoissa
vaikkapa erinimisinä. Ja saman voi tehdä myös
hakemistoille!
</dd>
<dt> Ville </dt><dd>Kuulostaa hyödylliseltä.
</dd>
</dl>

<p>
Ohjelman nimi on <code>ln</code>, ja se tekee oletuksena kovia linkkejä, jotka
ovat vähän erilaisia kuin symboliset linkit. Keskitymme tässä nyt
näihin jälkimmäisiin, eli pehmeisiin ja symbolisiin linkkeihin.
</p>

<pre class="example">
$ ln -s lähde kohde
</pre>

<dl class="org-dl">
<dt> Matias </dt><dd>Esimerkiksi näin:

<pre class="example">
$ ls
kissat
$ ls kissat
burgeri.txt  kalastaja  karvinen  siamilainen
$ ln -s kissat katit
$ ls katit
burgeri.txt  kalastaja  karvinen  siamilainen
</pre>
</dd>

<dt> Ville </dt><dd>Ja nytkö samat tiedostot on kahdessa paikassa ilman
että niitä kopioitiin?
</dd>
<dt> Matias </dt><dd>Ei! Sekä hakemisto <code>kissat</code> ja <code>katit</code> osoittavat
samaan hakemistoon, nimittäin <code>kissat</code>-hakemistoon.
Kuitenkin saat käsitellä kumpaakin hakemistoa
omalla nimellään – <code>katit</code> näkyy systeemissä aivan
omana hakemistonaan, ainakin mitä nimeen tulee.
</dd>
</dl>

<p>
Symbolisia linkkejä on helppoa tarkastella <code>ls -l</code> -listauksessa:
</p>

<pre class="example">
$ ls -l
lrwxrwxrwx 1 matias matias   6 Jul 16 17:23 katit -&gt; kissat
drwxr-xr-x 2 matias matias  73 Jul 15 17:03 kissat
</pre>

<p>
Näemme, että <code>katit</code> on symbolinen linkki, joka osoittaa oikein nuolen
kanssa kohti hakemistoa <code>kissat</code>.
</p>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-sec-1-5">
<h3 id="sec-1-5">Joitain käytettyjä komentorivisovelluksia</h3>
<div id="text-1-5" class="outline-text-3">
<p>
Kertaillaan ensin Unix-filosofian toista tärkeätä sääntöä, koska sen ansiosta
komentorivi on niin voimakas kuin se on. Sitten tarkastelemme perustyökaluja
tiedostojen tutkimiseksi.
</p>
</div>

<div class="outline-4" id="outline-container-sec-1-5-1">
<h4 id="sec-1-5-1">Kaikki on legopalikoita</h4>
<div id="text-1-5-1" class="outline-text-4">
<dl class="org-dl">
<dt> Matias </dt><dd>Okei. Oletteko valmiita sukeltamaan kunnolla
sisään? Aloitan tämmöisestä asiasta, jotta meillä
olisi jotain palikoita valmiiksi tulevia koitoksia
varten.
</dd>
<dt> Ville </dt><dd>Mitä ihmeen palikoita?
</dd>
<dt> Matias </dt><dd>No ok. Minä tykkään ajatella unix-ohjelmia ikään
kuin legopalikoina.
</dd>
<dt> Ville </dt><dd>Tä, miksi?
</dd>
<dt> Matias </dt><dd>Koska ne ovat niin pieniä? Jokainen ohjelma tekee
pienen homman, ja jos mitenkään mahdollista, jättää
epäoleelliset tehtävät muille ohjelmille.
</dd>
<dt> Hemmo-Joachim </dt><dd>Jaa. Mun mielest tuo <i>Tulikettu</i> on aika kaukana
legopalikasta.
</dd>
<dt> Matias </dt><dd>Nykypäivän graafiset käyttöliittymät tekevät
palikoinnista aika vaikeata. Mutta vanhaan hyvään
aikaan kaikki oli komentorivillä, ja
Unix-filosofian säännöistä kultaisin menee näin
(ulkomuistista!):

<p>
Pane ohjelmasi tekemään vain yksi tarkkaan määrätty
tehtävä, ja tee se hyvin! Tee ohjelmista
kasattavia. Luota tekstirajapintoihin, sillä se on
universaali viestintätapa.
</p>
</dd>

<dt> Ville </dt><dd>No olipa se syvällistä.
</dd>
<dt> Hemmo-Joachim </dt><dd>Mikäs tuossa tekstissä niin viehättää? Eikö saa
kuvia olla?
</dd>
<dt> Matias </dt><dd>Kuvat taitavat tehdä poikkeuksen, mutta tekstiä on
helppo käsitellä, ihmisenkin. Se ei kärsi
teknisistä ominaisuuksista tavujen alapuolella:
sitä on helppo lähettää verkon yli. Hätätapauksessa
ihminenkin voi ottaa editorin kauniiseen käteen, ja
lukea helposti tekstimuotoista syötettä.

<p>
Eikä puhdas teksti varmasti tule vanhenemaan
formaattina kuten joku Word-dokumentti.
</p>
</dd>
<dt> Hemmo-Joachim </dt><dd>Mitä tarkoitat — että pystyn lihavoimaan ja
muotoilemaan puhdasta tekstiä?
</dd>
<dt> Matias </dt><dd>Ei Hemmo. Yritän sanoa, että kun olet valmis, niin
sinun ei tarvitse. <code>&lt;grin&gt;</code>
</dd>
</dl>
</div>
</div>
<div class="outline-4" id="outline-container-sec-1-5-2">
<h4 id="sec-1-5-2">Tärkeimmät palikat</h4>
<div id="text-1-5-2" class="outline-text-4">
<p>
Listataan seuraavaksi käsiteltäviä ohjelmia, ja niiden kuvaukset
lyhyesti taulukon muodossa. Nyt puhutaan näistä sovelluksista
tiedostojenkäsittelijöinä, mutta tämä käsite muuttuu nopeasti
myöhemmin. Toivottavasti pysytte kärryillä.
</p>

<table frame="hsides" rules="groups" cellpadding="6" cellspacing="0" border="2">


<colgroup>
<col class="left"></col>

<col class="left"></col>
</colgroup>
<thead>
<tr>
<th class="left" scope="col">Ohjelma</th>
<th class="left" scope="col">Tehtävä</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>cat</code></td>
<td class="left">Yhdistä/näytä tiedosto</td>
</tr>

<tr>
<td class="left"><code>grep</code></td>
<td class="left">Hakee tekstiä tiedostosta</td>
</tr>

<tr>
<td class="left"><code>wc</code></td>
<td class="left">Laskee merkkejä/sanoja/rivejä</td>
</tr>

<tr>
<td class="left"><code>sort</code></td>
<td class="left">Lajittelee tiedostoa</td>
</tr>

<tr>
<td class="left"><code>head</code></td>
<td class="left">Näytä ensimmäiset rivit</td>
</tr>

<tr>
<td class="left"><code>tail</code></td>
<td class="left">Näytä viimeiset rivit</td>
</tr>

<tr>
<td class="left"><code>less</code></td>
<td class="left">Näyttää tiedoston selattavassa muodossa</td>
</tr>
</tbody>
</table>

<dl class="org-dl">
<dt> Ville </dt><dd>Kissojako tämä käsittelee?
</dd>
<dt> Matias </dt><dd>Arvasin, että joku puuttuu tähän. Se on lyhenne
sanasta <b>concatenation</b>, eli yhdistäminen. Sillä
pystyy sattumoisin myös lukemaan tiedoston
sisältöä. Vaikka se ei ole tarkoitettu siihen.
</dd>
<dt> Hemmo-Joachim </dt><dd>Ja mä kun luulin, että se on just siihen hommaan.
Toimii täydellisesti!
</dd>
<dt> Matias </dt><dd>Toki se toimii hyvin siihen, jos on lyhyestä
tekstistä kyse.
</dd>
</dl>
</div>

<div class="outline-5" id="outline-container-sec-1-5-2-1">
<h5 id="sec-1-5-2-1"><code>cat</code></h5>
<div id="text-1-5-2-1" class="outline-text-5">
<p>
Tiedostojen yhdistämiseen sopiva <code>cat</code> on helppokäyttöinen, eikä sisällä
ylimääräisiä ominaisuuksia. Kuten kuvaan sopiikin. Sillä voi sattumoisin
todellakin katsella tiedostojen sisältöjä:
</p>

<pre class="example">
$ cat foo.txt
Foo-tiedoston sisältö tulee tähän
muokkaamattomana.
$ cat bar.txt
Barbarbar
$ cat foo.txt bar.txt
Foo-tiedoston sisältö tulee tähän
muokkaamattomana.
Barbarbar
$
</pre>

<p>
Formaalimmin sanottuna <code>cat</code> lukee argumentteina annettuja tiedostoa yhden tai
useamman, ja tulostaa ne annetussa järjestyksessä peräkkäin eteenpäin:
</p>

<pre class="example">
cat [file1] [file2] [...]
</pre>

<dl class="org-dl">
<dt> Ville </dt><dd>Eli <code>cat tiedosto.txt</code> näyttää sen tuossa ruudulla.
Mitenkäs jos tiedosto on pitkä niin se ei mahdu.
</dd>
<dt> Matias </dt><dd>Sitä varten käytetään oikeata lukijaa, tai
<i>pageria</i> kuten Unixeissa sanotaan (pager,
sivuttaja). Käsittelemme yhden pagerin nimeltä
<code>less</code> tässä myöhemmin.
</dd>
</dl>
</div>
</div>
<div class="outline-5" id="outline-container-sec-1-5-2-2">
<h5 id="sec-1-5-2-2"><code>wc</code></h5>
<div id="text-1-5-2-2" class="outline-text-5">
<dl class="org-dl">
<dt> Hemmo-Joachim </dt><dd>Hei tarviiks käydä veskis? Höhö
</dd>
<dt> Matias </dt><dd>Oikein hyvä, oikein hyvä. Mutta <code>wc</code> tulee tylsästi
sanoista <code>word count</code>. Se laskee tiedostojen
sisällöistä sanamääriä. Merkit, sanat, rivit.
Hyödyllinen joihinkin hommiin, mutta aika harvoin
nykypäivänä.
</dd>
<dt> Hemmo-Joachim </dt><dd>Niin, sanathan voi laskea OpenOfficessakin.
</dd>
<dt> Ville </dt><dd>Mutta tämähän on kätsy.
</dd>
<dt> Matias </dt><dd>Tällä on käyttöä erityisesti rivien laskemisessa,
mutta tokihan puhtaista tiedostoistakin pitää
jotenkin sanat saada lasketuksi.
</dd>
</dl>

<p>
Sanalaskuri <code>wc</code> käyttäytyy samalla tavalla kuin <code>cat</code>:
</p>

<pre class="example">
$ wc foo.txt        
 2  5 56 foo.txt
$ wc foo.txt bar.txt 
 2  5 56 foo.txt
 1  1 10 bar.txt
 3  6 66 total
$
</pre>

<p>
Annetut kolme lukua ovat järjestyksessä rivien, sanojen ja merkkien lukumäärä.
Jos tiedostoja antaa enemmän kuin yhden, <code>wc</code> laskee myös kaiken yhteen. Voit
myös laskea vain tiettyä arvoa seuraavien asetusten kanssa:
</p>

<dl class="org-dl">
<dt> <code>-w</code> </dt><dd>laske vain sanat
</dd>
<dt> <code>-c</code> </dt><dd>laske vain merkit
</dd>
<dt> <code>-l</code> </dt><dd>laske vain rivit
</dd>
<dt> <code>-L</code> </dt><dd>laske tiedoston pisin rivi
</dd>
</dl>

<p>
Näistä viimeistä on helppo käyttää tilanteissa, joissa tiedostojen täytyy olla
oikein muotoiltuja. Monesti on annettu esimerkiksi 80 merkin rivinpituusraja.
Näin helppoa se on:
</p>

<pre class="example">
$ wc -L foo.txt
50 foo.txt
</pre>
</div>
</div>
<div class="outline-5" id="outline-container-sec-1-5-2-3">
<h5 id="sec-1-5-2-3"><code>grep</code></h5>
<div id="text-1-5-2-3" class="outline-text-5">
<p>
<a name="grep" id="grep"></a>
</p>

<dl class="org-dl">
<dt> Matias </dt><dd>Siirrytään jo kovempiin välineisiin. Onko koskaan
ollut tarvetta hakea jotain tekstiä tiedostoista?
</dd>
<dt> Ville </dt><dd>Kysytkin.
</dd>
<dt> Matias </dt><dd>Näin on. Vanha kunnon <code>grep</code> hakee meille kaikki
osumat, joita hakusanamme antaa.
</dd>
<dt> Hemmo-Joachim </dt><dd>Käyttääks se googlea?
</dd>
<dt> Matias </dt><dd>Ei. Haemme aina jostain tiedostosta. Annetun
tiedoston kaikki ne rivit tulevat tulostetuksi, jos
riviltä löytyy annettu hakusana. Ei ole vaikeata!
</dd>
<dt> Hemmo-Joachim </dt><dd>No ei pitäisi olla.
</dd>
<dt> Ville </dt><dd>No, miten tätä käytetään?
</dd>
</dl>

<p>
Yksinkertainen kuvio on seuraava:
</p>

<pre class="example">
grep PATTERN [FILE]...
</pre>

<p>
Kolme pistettä valinnaisen argumentin perässä tarkoittakoon, että tiedostoja
saa taas olla enemmänkin kuin yksi. Kaikista haetaan järjestyksessä. Sanaa
<b>PATTERN</b> käytetään paljon Unix-maailmassa. Se tarkoittaa siis hakusanaa, joka
voi olla paljon enemmänkin kuin pelkkä sana. Palaamme näiden patternien
pimeälle puolelle myöhemmin.
</p>

<p>
Oletetaan, että meillä on seuraavanlainen tiedosto, jossa on Matiaksen
suosikkielokuvien listaukset:
</p>

<pre class="example">
$ cat Stooges.txt
Vuosi   Jakso                   Kuka?
--------------------------------------------
1950    Studio Stoops           Shemp
1940    From Nurse To Worse     Curly
1958    Quiz Whiz               Joe
1935    Uncivil Warriors        Curly
1946    Monkey Businessmen      Curly
1950    Punchy Cowpunchers      Shemp
1948    Hot Scots               Shemp
1947    All Gummed Up           Shemp
1942    Three Smart Saps        Curly
$
</pre>

<p>
Jos tämä olisi kokonainen listaus <b>Three Stooges</b> -elokuvia, niin tämä olisi
vähän pidempi listaus, niin haun käyttö olisi merkityksellisempää. Nyt
kuitenkin näin.
</p>

<p>
Nyt jos haluaisimme tarkastella kaikkia Shempin tekemiä jaksoja, niin
<code>grep</code>:iä käyttämällä asia on jo hoidossa:
</p>

<pre class="example">
$ grep Shemp Stooges.txt
1950    Studio Stoops           Shemp
1950    Punchy Cowpunchers      Shemp
1948    Hot Scots               Shemp
1947    All Gummed Up           Shemp
</pre>

<p>
Mitään ei ole poistettu: grep vain näyttää osuman saaneet rivit tiedostosta,
eikä muuta. Vastaavalla tavalla voimme hakea vaikka minkälaista. Hakusana ei
oletuksena rajoitu mitenkään kokonaisiksi sanoiksi, vaan jos <code>grep</code> löytää sen
keskeltä toista sanaa, niin rivi tulostetaan. Tästä on erityisesti etua, jos
vähän haittaakin:
</p>

<pre class="example">
$ grep 195 Stooges.txt
1950    Studio Stoops           Shemp
1958    Quiz Whiz               Joe
1950    Punchy Cowpunchers      Shemp
</pre>

<p>
Näin saimme kaikki 1950-luvulla esitetyt jaksot listatuksi, kun olimme vähän
ovelia ja tiesimme tiedoston rakenteesta etukäteen. Säännöllisten lausekkeiden
avulla voimme määrätä tarkempaan, missä ja miten hakusana saa esiintyä.
</p>

<dl class="org-dl">
<dt> Hemmo-Joachim </dt><dd>Joo <code>grep</code> on tuttu, mutta ärsyttää aina kirjoittaa
hakusana isolla tai jotenkin. Ei osaa muuten
löytää. Esimerkiksi tuo Stooges-tiedosto, <code>grep</code> ei
löydä mitään jos haen "shemp"illä.
</dd>
<dt> Matias </dt><dd>Joo, Unixeissa ollaan yleensä tarkkoja
kirjainkoosta. Käytä grepille asetusta <code>-i</code>,
jolloin se jättää koon huomioimatta.
</dd>
<dt> Ville </dt><dd>Voi veljet. Miten te jaksatte katsoa noin vanhoja
elokuvia?
</dd>
</dl>

<p>
Tarkastele kirjainkoon merkitystä ja <code>-i</code> -flagin käyttöä:
</p>

<pre class="example">
$ grep joe Stooges.txt
$ grep -i joe Stooges.txt
1958    Quiz Whiz               Joe
</pre>

<p>
Keskeiset työkalut tiedostojen käsittelyyn ovat esitetyt <code>cat</code> ja <code>grep</code>.
Näistä jälkimmäinen omaa suuria voimia sisäänsä, mutta emme voi vielä
käsitellä kaikkea.  Siihen palaillaan säännöllisissä lausekkeissa sitten.
Katsellaan vielä pari pikkuohjelmaa tiedostojen käsittelyyn, ja sitten yksi
isompi, jolla on paljon käyttöä isompien tiedostojen luennassa.
</p>
</div>
</div>
<div class="outline-5" id="outline-container-sec-1-5-2-4">
<h5 id="sec-1-5-2-4"><code>sort</code></h5>
<div id="text-1-5-2-4" class="outline-text-5">
<dl class="org-dl">
<dt> Matias </dt><dd>Lajittelu on melko tyypillinen ongelma, ja
helppokin sellainen. Ohjelma nimeltä <code>sort</code> hanskaa
tiedostojen rivien lajittelun.
</dd>
<dt> Hemmo-Joachim </dt><dd>No annahan esimerkki.
</dd>
<dt> Matias </dt><dd>Käyttäkäämme Stooges.txt -tiedostoa taas apunamme.
Voisimme esimerkiksi ajaa sen helposti
järjestykseen vuosiluvun mukaan. Nyt siinä on toki
mukana se otsikko ja viiva, ja se vähän sotkee
asiaamme.

<pre class="example">
$ sort Stooges.txt
--------------------------------------------
1935    Uncivil Warriors        Curly
1940    From Nurse To Worse     Curly
1942    Three Smart Saps        Curly
1946    Monkey Businessmen      Curly
1947    All Gummed Up           Shemp
1948    Hot Scots               Shemp
1950    Punchy Cowpunchers      Shemp
1950    Studio Stoops           Shemp
1958    Quiz Whiz               Joe
Vuosi   Jakso                   Kuka?
</pre>
</dd>

<dt> Ville </dt><dd>… eli sortista ei ole mihinkään käytännölliseen
tuon ongelman takia?
</dd>
<dt> Matias </dt><dd>Ei nyt ihan niinkään – kuten näette, rivit ovat
kuitenkin järjestyksessä. Tämän asian voi korjata
"näppärästi", mutta siihen joudumme palaamaan vasta
myöhemmin!
</dd>
<dt> Hemmo-Joachim </dt><dd>Eihän tuo ole paha rasti korjata itte takaisin
tota.
</dd>
<dt> Matias </dt><dd>Lisättäköön, että <code>sort</code> on puhtaille tiedostoille,
kuten juuri teimme, parhaimmillaan ilman otsikoita.
Siis ilman muotoiluja. Muotoiltua tekstiä
lajiteltaessa kannattaa hyödyntää kehittynyttä
editoria apunaan.

<p>
Ennen kuin tämä lässähtää huonoon demoon
lopullisesti, niin maustetaan asiaa sillä faktalla,
että tämmöistä taulukkomuotoista tekstiä <code>sort</code>
osaa lajitella myös sarakkeittain!
</p>
</dd>
<dt> Hemmo-Joachim </dt><dd>Elä?

<pre class="example">
$  sort -k 2 Stooges.txt
--------------------------------------------
1947    All Gummed Up           Shemp
1940    From Nurse To Worse     Curly
1948    Hot Scots               Shemp
Vuosi   Jakso                   Kuka?
1946    Monkey Businessmen      Curly
1950    Punchy Cowpunchers      Shemp
1958    Quiz Whiz               Joe
1950    Studio Stoops           Shemp
1942    Three Smart Saps        Curly
1935    Uncivil Warriors        Curly
$
</pre>
</dd>
</dl>

<p>
Ja mitä näettekään? Nyt tiedosto on lajiteltu toisen sarakkeen, eli
jakson nimen mukaan. Sitä varten on tuo optio <code>-k</code>, jolle annetaan
"kentän" numero. Tässä <code>sort</code> osaa haistella asian oikein, koska
meillä on simppeliä dataa. Oletuksena kenttä erottuu välilyönnistä,
jolloin esimerkiksi "All Gummed Up" on kolme erillistä kentää sortin
silmissä. Kaikki lajittuu oikein, koska muuta ei tarvitakaan kuin
lajitella toisesta sanasta, eli jakson nimestä alkaen rivin loppuun
saakka.
</p>
</div>
</div>
<div class="outline-5" id="outline-container-sec-1-5-2-5">
<h5 id="sec-1-5-2-5"><code>head</code> ja <code>tail</code></h5>
<div id="text-1-5-2-5" class="outline-text-5">
<p>
Kuin paita ja peppu. Jos ohjelmien nimet antavat mitään irti, niin olet jo
hyvillä jäljillä.
</p>

<dl class="org-dl">
<dt> Matias </dt><dd>Nyt on pari helppoa ohjelmaa. Jos teillä on pitkä
tiedosto edessänne, niin siitä voi olla joskus
mukava katsoa vain alku tai loppu. Tätä varten on
<code>head</code> – alkua varten ja <code>tail</code> sitten … ?
</dd>
<dt> Hemmo-Joachim </dt><dd>No loppua varten.
</dd>
<dt> Matias </dt><dd>Tulihan se sieltä.
</dd>
</dl>

<p>
Käsitellään molemmat yhdessä: <code>head</code> (ja <code>tail</code>) lukevat 10
ensimmäistä (tai viimeistä) riviä tiedostosta, ja tulostavat ne.
Lukeaksesi enemmän tai vähemmän, voit antaa oman numeron <code>-n</code>
-asetukselle:
</p>

<pre class="example">
$ head -n 15 pitkäteksti.txt
</pre>

<p>
Lukee tietenkin 15 riviä kymmenen sijaan.
</p>

<dl class="org-dl">
<dt> Ville </dt><dd>No nämä minäkin ymmärrän ilman eri selvittelyjä.
Mutta mihinkähän näitäkin tarvitsee… onhan tuossa
tuo vierityspalkki vieressä.
</dd>
<dt> Matias </dt><dd>Aina ei ole sitä, etkä varmaan sinäkään jaksa
10000-rivistä tiedostoa tulostaa kokonaan näytölle
ja sitten skrollailla ylös, jotta näet tekstin
otsikon?
</dd>
<dt> Ville </dt><dd>No hyvä on. Mutta <code>tail</code> on vielä turhempi. Jos
minä tulostan jotain tässä komentorivillä näytölle
niin ainakin ne viimeiset rivit jäävät aina
näkyviin!
</dd>
<dt> Matias </dt><dd>No näinhän se tekee, mutta <code>tail</code> sisältää yhden
lisäerikoisuuden, joka tekee siitä erityisen
hienon.
</dd>
</dl>

<p>
Tail-ohjelmalla voit reaaliaikaisesti seurata annetun tiedoston loppuun
kirjoitettuja rivejä. Tämä asetus on nimeltään <code>-f</code>, ja siinä moodissa <code>tail</code>
jää ikuiseen lukusilmukkaan odottamaan uuden datan ilmestymistä tiedostoon.
Kaikki uudet rivit tulostetaan sitten esille. Sitä on hankala demonstroida
oppaassa, mutta kahdessa eri konsolissa voit kokeilla asiaa näin:
</p>

<p>
Yhdessä konsolissa seuraavanlainen komento:
</p>

<pre class="example">
$ while true ; do sleep 1 ; date &gt;&gt; date.txt ; done
</pre>

<p>
Se jää suorittumaan hiljalleen. Avaa toinen konsoli, ja nyt voit <code>tail</code>
-ohjelman avulla seurata reaaliaikaisesti tiedoston <code>date.txt</code> kasvamista:
</p>

<pre class="example">
$ tail -f date.txt
Wed Jun 29 19:06:26 EEST 2011
Wed Jun 29 19:06:27 EEST 2011
Wed Jun 29 19:06:28 EEST 2011
Wed Jun 29 19:06:29 EEST 2011
... jne ...
</pre>

<p>
Tiedostoon pitäisi ilmestyä sekunnin välein yksi uusi rivi, jossa on
<code>date</code>-ohjelman tuloste kullakin kutsukerralla. Kun olet huvitellut tarpeeksi,
näppäinyhdistelmä <code>&lt;C-c&gt;</code> sekä tailille että toistaiseksi mystiselle
<code>while</code>-kokonaisuudelle saa ohjelmat hiljenemään.
</p>

<dl class="org-dl">
<dt> Matias </dt><dd>Itse käyttelen tätä toimintoa omien javaohjelmien
debuggauksessa. Ja myöspä unixien omat
järjestelmälogit on helppo panna taustalle
rullaamaan tämän seurannan avulla!
</dd>
<dt> Ville </dt><dd>Aika päheetä.
</dd>
</dl>
</div>
</div>
<div class="outline-5" id="outline-container-sec-1-5-2-6">
<h5 id="sec-1-5-2-6"><code>less</code></h5>
<div id="text-1-5-2-6" class="outline-text-5">
<p>
<a name="less" id="less"></a>
</p>

<p>
Esitetyt ohjelmat ovat tähän mennessä kaikki olleet yhtälailla ihmisen
kuin koneen käyttöä varten. Nyt esitetään tekstitiedostoja lukeva
<code>less</code>, jonka toiminnallisuus on puhtaasti ihmisen käyttöä varten.
</p>

<p>
On nyt mainittava, että <code>less</code> ei kuulu vakiokalustoon. Jos käy huono
arpa kohdalle, lessiä ei ole asennettu Unixissasi. Joskus pagerina on
käytettävä vanhempaa ohjelmaa nimeltä <code>more</code> (DOS-käyttäjät
muistanevat samannimisen), mutta se on paljon rajoittuneempi.
Sanontakin sen sanoo: <b>less is more</b>.
</p>

<dl class="org-dl">
<dt> Matias </dt><dd>No niin. Pitkiä tiedostoja – vaikkapa irc-logeja
– on tylsä lukea <code>cat</code>:in tai <code>grep</code>:in avulla.
</dd>
<dt> Ville </dt><dd>Sanoppa muuta.
</dd>
<dt> Hemmo-Joachim </dt><dd>Eikö se <code>irssi</code> ole just tuota varten?
</dd>
<dt> Matias </dt><dd>No Hemmo, irssi säilyttää vain sen ja sen verran
logia. Vanhoja muistellessasi pitää yleensä
turvautua logeihin, jos niitä olet nauhoitellut.
</dd>
<dt> Hemmo-Joachim </dt><dd>No niinhän se on. Olen joskus kokeillut <code>grep</code>:illä
hakea jotain juttua logista ja ei siitä ole tullut
mitään.
</dd>
<dt> Matias </dt><dd><code>less</code> helpottaa siinä hakemisessa.
</dd>
<dt> Ville </dt><dd>Eli tuo esittelemäsi <code>grep</code> onkin ihan turha, jos
                   <code>less</code>:llä voi hakea helpommin ja paremmin?
</dd>
<dt> Matias </dt><dd>Ei niinkään. Näet kyllä, että näillä tehdään
erityyppisiä hakemisia.
</dd>
</dl>

<p>
Peruskäyttö:
</p>

<pre class="example">
less [FILE]...
</pre>

<p>
Ja nyt <code>less</code> avaa tiedostosi koko ruudulle.  Voit selata tiedostoa
nuolinäppäimin tai vaikka käyttää <code>&lt;Page Up/Down&gt;</code>:ia. Selaimesta tutulla
tavalla voit vierittää alaspäin välilyönnistä. Voit palata ylöspäin: temppu,
jota vanha <code>more</code> ei osannut. Mutta jos ajat lessiä komentoriviltä jonkin
terminaalisovelluksen läpi, niin terminaalisi vierityspalkit tuskin toimivat
kuten haluat. Less ei ole sellainen ns. <b>batch</b>-sovellus kuten puhuimme
alussa. Se on interaktiivinen kokoruudun ohjelma, jotka yleistyivät vasta
80-luvulla.
</p>

<dl class="org-dl">
<dt> Ville </dt><dd>Hommasin jonkun tiedoston tähän ja <code>less</code> nyt tässä
auki. Mitä tässä voi tehdä, muutakin kuin kelata
ylös- ja alaspäin ja lukea?
</dd>
<dt> Matias </dt><dd>Voit hakea tiedostostasi hakusanoilla, voit ladata
uusia tiedostoja ja vaihdella niiden välillä; voit
hyppiä tiedostosta komentoriville ja sitten palata
takaisin. Voit asettaa kirjanmerkkejä kohtiin ja
palata niihin yhdellä näppäinyhdistelmällä
myöhemmin… <code>less</code> osaa kaikenlaista.

<p>
Mutta me käymme vain pienen osan kaikesta tästä, koska sillä
pärjää hyvin.
</p>
</dd>
</dl>

<p>
Seuraavassa taulukossa on listaus <code>less</code>:in paljon käytettyjä komentoja.
</p>

<table frame="hsides" rules="groups" cellpadding="6" cellspacing="0" border="2">


<colgroup>
<col class="left"></col>

<col class="left"></col>
</colgroup>
<thead>
<tr>
<th class="left" scope="col">Näppäin</th>
<th class="left" scope="col">Tekee</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">Ylä- ja alanuoli</td>
<td class="left">selaa tiedostoa ylös/alas</td>
</tr>

<tr>
<td class="left"><code>h</code></td>
<td class="left">lessin ohjetiedosto</td>
</tr>

<tr>
<td class="left"><code>q</code></td>
<td class="left">sulje ohje tai sulje <code>less</code></td>
</tr>

<tr>
<td class="left"><code>j</code>, <code>k</code></td>
<td class="left">rivi alas / rivi ylös</td>
</tr>

<tr>
<td class="left">PgUp/Dw</td>
<td class="left">Sivu kerrallaan ylös/alas</td>
</tr>

<tr>
<td class="left"><code>&lt;C-f&gt;</code> ja <code>&lt;C-b&gt;</code></td>
<td class="left">Sivu alas/ylös</td>
</tr>

<tr>
<td class="left"><code>/PAT&lt;CR&gt;</code></td>
<td class="left">Haku tiedostosta</td>
</tr>

<tr>
<td class="left"><code>n</code></td>
<td class="left">Seuraava osuma</td>
</tr>

<tr>
<td class="left"><code>N</code></td>
<td class="left">Edellinen osuma</td>
</tr>
</tbody>
</table>

<dl class="org-dl">
<dt> Matias </dt><dd>Ja tarkennettakoon se, että <code>&lt;C-f&gt;</code> tarkoittaa
control+f:ää. Mikä puolestaan tarkoittaa, että
kontrol-äffällä ei tehdä hakua kuten
Windows-maailmassa tehdään.

<p>
Toinen tarkennus on, että <code>&lt;CR&gt;</code> tarkoittaa enterin
painallusta.
</p>
</dd>
<dt> Ville </dt><dd>Miksi kehittäjät eivät ole voineet tehdä samalla
tavalla toimivaa systeemiä. On taas pitänyt
taistella Microsoftia vastaan! :F
</dd>
<dt> Matias </dt><dd>Otahan huomioon, että nämä konventiot ovat rutkasti
vanhempia kuin Windows.
</dd>
<dt> Hemmo-Joachim </dt><dd>Tuossa on joitain päällekkäisyyksiä. Onko niissä
eroja?
</dd>
<dt> Matias </dt><dd>Ei ole. Sisällytin pari kohtaa, jotka ovat
keskenään samoja. Pistin ne mukaan, jos joukossamme
on joku <code>vi</code>-käyttäjä. Joskus on ihan mukava
kirjoitella ja hypätä lessiin ilman, että pitää
kättä siirtää nuolinäppäimille.
</dd>
<dt> Hemmo-Joachim </dt><dd>Ja mitenköhän se sitten onnistuu?
</dd>
<dt> Ville </dt><dd>Justhan sä luit tuon taulukon. Siinä näkyy niitä
näppäimiä.
</dd>
</dl>

<p>
Esimerkissämme nyt voisi olla pitkä, 170-rivinen
<code>Stooges.txt</code>-tiedosto, josta haluamme haeskella muuten vain vaikkapa
hevosaiheisia jaksoja.
</p>

<pre class="example">
$ less Stooges.txt
/Horse&lt;CR&gt;
n
n
q
</pre>

<p>
Tämä olisi esimerkkitilanne, jossa haetaan hakusanalla "Horse" ja ilmeisesti
tehdäänkin löytöjä. Kahdesti on painettu <code>n</code>-näppiä, eli on haettu edelleen
uusia Horse-esiintymiä tiedostosta. Sitten on lopeteltu.
</p>

<dl class="org-dl">
<dt> Matias </dt><dd>Enpä jaksa enempää esitellä. <code>less</code> on paljon
käytetty ohjelma, ja se on riittävän
yksinkertainen. Jos on ollut tarvetta millekään
isommalle niin olen vaihtanut suosiolla editorin
puolelle.
</dd>
<dt> Hemmo-Joachim </dt><dd>Ja hei, siihen on muuten <code>less</code>:in puolelta oma
komento.
</dd>
<dt> Matias </dt><dd>No katsos vain. Olet ollut tarkkana. Tiedostoa
selattaessa näppäin <code>v</code> aktivoi kyseisen tiedoston
vapaavalintaisessa editorissa. Mutta sen täytyy
olla asetettuna tietyssä muodossa. Palaamme
editoreihin tuotapikaa!

<p>
Tämä on hyvä yhdistelmä, <code>less</code> ja tuo komento <code>v</code>. Nopeasti
käynnistyvällä lessillä helposti hakee oikean tiedoston, ja
sitten voi editoida sitä yhden näppäinpainalluksen takaa.
</p>
</dd>
</dl>

<p>
Jees. Meikä kuunteleekin Kraftwerkin levyn vielä loppuun ja sitten suihkuun.
</p>
</div>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-sec-1-6">
<h3 id="sec-1-6">Man</h3>
<div id="text-1-6" class="outline-text-3">
<dl class="org-dl">
<dt> Matias </dt><dd>Nyt on korkea aika antaa teille lusikka omaan
käteen niinsanotusti. Unix voi olla aika
vaikeaselkoinen, mutta onneksi ohjeita on edes
yritetty koostaa. Usein ovat onnistuneetkin!
</dd>
<dt> Hemmo-Joachim </dt><dd>Vanha kunnon <code>man</code>. Kyllä minä sen tiedän.
</dd>
<dt> Ville </dt><dd>Minäpä en.
</dd>
<dt> Matias </dt><dd>Ohjelmilla on hyvin tyypillisesti ohjetiedostoja
vino pino – vain huonoilla softilla puuttuu.

<p>
Nämä ohjeet sijaitsevat tietyssä hakemistossa, ja
niitä kutsutaan luonnollisesti <b>manual pageiksi</b>.
Lyhyesti – Unix-miehet pitävät lyhyestä –
<b>manpaget</b>.
</p>
</dd>
<dt> Ville </dt><dd>Ja <code>man</code> on sitten ohjelma näiden sivujen
näyttämiseksi?
</dd>
<dt> Matias </dt><dd>Näin. Man ei tee paljoa, mutta se tekee osansa,
koostaen muista työkaluista. Se purkaa pakatut
ohjetiedostot auki, muotoilee ne ja sitten syöttää
ne jollekin <b>pagerille</b>, eli nykyisin
<code>less</code>-ohjelmalle.
</dd>
<dt> Hemmo-Joachim </dt><dd>Kaikki <code>less</code>-komennot toimivat <code>man</code>:lla. Se on
tykki juttu.
</dd>
<dt> Matias </dt><dd>Jep. Jossain vanhoissa systeemeissä voi <code>less</code>
puuttua ja alkukantainen <code>more</code> astuu esiin. Et
halua puuhastella sen kanssa, usko pois!
</dd>
</dl>

<p>
Yleiskäyttö <code>man</code>-ohjelmalle on helppoa. Saadaksesi ohjelman <code>xyz</code> ohjeet
näytölle komento kuuluu:
</p>

<pre class="example">
$ man xyz
</pre>

<p>
Unix-koodausta harjoittaville C-miehille <code>man</code> yleensä sisältää myös kaikki
C-systeemikirjastot ja niiden käytön. Silloin voit hakea funktiokuvauksia
suoraan sektiosta 3: "C Library Functions":
</p>

<pre class="example">
$ man 3 printf
</pre>

<dl class="org-dl">
<dt> Matias </dt><dd>Ja <code>man</code> on about siinä. Katsokaa komennolla <code>man
                   man</code> lisätietoja asiasta. Jos <code>less</code>:n perusteet
unohtuivat opetella, niin olisi hyvä aika katsoa
keskeiset näppäinkomennot sille.
</dd>
<dt> Hemmo-Joachim </dt><dd>Haa–yhden kikan unohdit esitellä. Voit hakea
kaikista asennetuista ohjeista hakusanoin:

<pre class="example">
$ man -k hakusana
</pre>
</dd>

<dt> Matias </dt><dd>Ähäkutti: <code>-k</code> toki hakee hakusanoin kuvauksista,
mutta tekee niin vain lyhyistä kuvauksista. Jos
haluat oikeasti selata koko ohjetiedoston sisältä
(hidasta!) niin seuraava komento voi tehdä parempaa
työtä:

<pre class="example">
$ man -S 1 -K hakusana
</pre>

<p>
Nyt <code>man</code> hakee kaikista ohjelmaoppaista (sektio 1) ja niiden
sisällöistä hakusanalla <code>hakusana</code>. Se kyselee jokaisen osuman
saaneen tiedoston jälkeen, luetaanko se läpi.
</p>
</dd>
<dt> Hemmo-Joachim </dt><dd>Kah, aina sitä oppii.
</dd>
<dt> Matias </dt><dd>No ei <code>man -k</code> huono idea ole, mutta siihen
kannattaa soveltaa vähän greppiä, jotta saat
tiiviimmän listan osumista.
</dd>
<dt> Ville </dt><dd>Miten sitä greppiä nyt sovelletaan tuohon hommaan?
</dd>
<dt> Matias </dt><dd>Käsittelemme sitä seuraavassa isossa luvussa.
</dd>
</dl>
</div>
</div>
<div class="outline-3" id="outline-container-sec-1-7">
<h3 id="sec-1-7">Virtojen ohjailua ja putket</h3>
<div id="text-1-7" class="outline-text-3">
<p>
Nyt meillä on riittävästi aineksia päästä käsiksi komentorivin
todelliseen taikaan. Tätä ennen olemme pelailleet yksittäisillä
ohjelmilla, käsitellen yksittäisiä tiedostoja. Tämä on yhtä tehokasta,
ellei tehokkaampaakin tehdä graafisin sovelluksin. Seuraava vaihe on
oppia Unixin vahvan moniajon eräs ilmenemä: putket ja syötevirtojen
ohjailu. Tämän jälkeen graafiset ohjelmat jäävät kauas taakse
kasattavuudessa.
</p>

<p>
Unix-ohjelmat ovat, kuten muistanette, kuin legopalikoita. Yksi
ohjelma tekee yhden tehtävän mahdollisimman hyvin. Ja näitä voi
kasata, kytkeä peräkkäin, tekemään monimutkaisempia hommia.
Perusohjelmia on kolmea päätyyppiä:
</p>

<ul class="org-ul">
<li><b>Lähteitä</b> (sources), jotka luovat tietovirtaa tyhjästä.
</li>
<li><b>Muuntimia</b> (transformers), jotka muuttelevat annettua tietovirtaa
ja lähettävät sen eteenpäin.
</li>
<li><b>Altaita</b> (sinks), jotka laskevat virtaa johonkin päätepisteeseen,
esimerkiksi tiedostoksi.
</li>
</ul>

<p>
Sääntönä on, että kaikki tietovirta, jota ei allastyyppinen ohjelma
nappaa, tulostetaan näkyville näytölle. Tähän sivuoireeseen perustuu
ihmisten suosiossa toimiva lähdetyyppinen <code>cat</code>.
</p>

<p>
Jos tietovirtaus ajatellaan vetenä, niin putkittelun käsite selkeää
toivottavasti. Lähteestä voidaan vetää putki muuntimeen, josta voidaan
vetää uusi putki uuteen muuntimeen, ja lopulta vedetään putki
altaaseen. Jos putkitus ei pääty altaaseen, niin tietovirta päätyy
näytölle. Yksittäisen ohjelman tulopäätä kutsutaan <b>standard in</b>
-virraksi, tai yleisemmin <code>stdin</code>:ksi. Tulopäätä kutsutaan <b>standard
outiksi</b> tai <code>stdout</code>:iksi.
</p>

<p>
Valtaosa ohjelmista voi toimia useassa eri moodissa, riippuen siitä,
miten sitä on käytetty. Käsittelemme vanhoja ohjelmia kappaleesta
<a href="#sec-1-5-2">Tärkeimmät palikat</a>, mutta voimme ehkä käsitellä uusiakin samalla,
jos on tarvetta.
</p>
</div>

<div class="outline-4" id="outline-container-sec-1-7-1">
<h4 id="sec-1-7-1">Lähteet</h4>
<div id="text-1-7-1" class="outline-text-4">
<p>
Vaikka molemmat <code>cat</code> ja <code>ls</code> ovat huonoja esimerkkejä lähdeohjelmista
oikeassa käytössä, niin ne ovat lähdeohjelmia, eli ne keräävät jotain
annettua tietoa tiedostosta tai muualta, ja tulostaa tietovirtaan.
<code>cat</code> voi myös toimia muuntimena, joka ei tosin tee mitään. <code>ls</code> sen
sijaan toimii toki jonkinmoisena lähteenä, joka tietää tiedostonimiä.
Kuitenkin tiedostonimiä varten on paljon parempiakin työkaluja, kuten
shellien omat jokerimerkit, jotka toimivat monessa paikassa.
</p>

<p>
Hyvä esimerkki lähdeohjelmasta on esimerkiksi <code>df</code>, joka raportoi
tietokoneen kovalevyjen tilankäytöstä. Joku vastaava voisi olla
esimerkiksi jonkun kirjoittama skripti, joka raportoi lukemattomien
sähköpostien lukumäärän.
</p>

<p>
Myös vähemmän käytetty lähdevaihtoehto on <code>less -f</code>, joka lukee
tiedostosta reaaliaikaisesti kaikki uudet rivit. Vaikka se jääkin
pyörimään ikilooppiin, eikä useimpina hetkinä ole uutta syötettä
luettavaksi, ei putki katkea. Tämä mahdollistaa hienoja kikkoja
reaaliaikaisen seurannan suodattamiseksi.
</p>

<p>
Lähteille tyypillistä onkin, että ne tekevät omia taikojaan, ja
tulostavat vastaavasti jotain jäsenneltyä ulos. Ne voivat kerätä
tietoja joko tiedostoista, tai muualta järjestelmästä. Mitä vain
voikaan ohjelma käyttää hyväkseen…
</p>
</div>
</div>
<div class="outline-4" id="outline-container-sec-1-7-2">
<h4 id="sec-1-7-2">Muuntimet</h4>
<div id="text-1-7-2" class="outline-text-4">
<p>
Muuntimet ovat tärkein osa putkittelua. Muunnin ottaa tietovirtaa
(<code>stdin</code>) ja tekee sille sananmukaisesti jotain muunnoksia. Lopuksi se
tulostaa muunnetun datan ulos <code>stdout</code>-virtaan.
</p>

<p>
Joskus muuntimia kutsutaan suodattimiksi, joka sopii paremmin
vesijohtotermistöön. Suodatintermin puolesta puhuu myös varmasti
kaikkein yleisin muunnin kaikista: <code>grep</code>. On aika ottaa putkituksesta
ensimmäinen esimerkki:
</p>

<pre class="example">
$ cat Stooges.txt 
Vuosi   Jakso                   Kuka?
--------------------------------------------
1950    Studio Stoops           Shemp
1940    From Nurse To Worse     Curly
1958    Quiz Whiz               Joe
1935    Uncivil Warriors        Curly
1946    Monkey Businessmen      Curly
1950    Punchy Cowpunchers      Shemp
1948    Hot Scots               Shemp
1947    All Gummed Up           Shemp
1942    Three Smart Saps        Curly
$ cat Stooges.txt | grep Curly
1940    From Nurse To Worse     Curly
1935    Uncivil Warriors        Curly
1946    Monkey Businessmen      Curly
1942    Three Smart Saps        Curly
</pre>

<p>
Haimme tiedostosta <code>Stooges.txt</code> kaikki Curlyn episodit. Nyt esimerkki on
tarkoituksella samanlainen kuin aiemmin kohdassa <a href="#grep">1.5.2.3</a> esitelty. Syystäkin:
<code>cat</code>:in käyttäminen tällä tavalla on täysin turhaa, vaikka siitä ei ole
kamalaa haittaa. Toisin sanoen, <code>grep</code> toimii sekä muuntimena että lähteenä.
Muunninkäytössä <code>grep</code> on enemmän kuin kotonaan.
</p>

<p>
Palikkakappaleessa <a href="#sec-1-5-2">Tärkeimmät palikat</a> esitellyt ohjelmat kaikki voivat
toimia vastaavalla tavalla sekä muuntimina että lähteinä.  Jos jätät
tiedostonimen pois, niin  ohjelma toimii muuntimena, ottaen tietovirtaa
vastaan. Tätä voit kokeilla ihan komentoriviltäkin. Esimerkiksi lajittelua
voit tehdä ilman tiedostoa. Kirjoitat suoraan <code>sort</code>-ohjelman stdin-virtaan
haluamasi asiat. Lopuksi painat <code>&lt;C-d&gt;</code>, joka on Unixissa feedin lopetustavu:
</p>

<pre class="example">
$ sort
juna
bussi
lentsikka
auto
&lt;C-d&gt;
auto
bussi
juna
lentsikka
$
</pre>

<p>
Vasta kun olet lopettanut kirjailemisen ja ilmoittanut <code>sort</code>:lle, että nyt
loppui teksti, niin <code>sort</code> lajittelee saamansa syötteen. Todellisuudessa
muuntimet pyrkivät tekemään muunnostöitä riveittäin, mutta <code>sort</code> tietenkin
joutuu odottamaan kaiken tiedon. Eihän sitä voi lajitella yhtä riviä
ilman, että sitä vertailee muiden kanssa!
</p>

<p>
<code>cat</code> on idioottivarma muuntaja, joka ei tee mitään. Lähettää vain takaisin
kaiken saamansa. Se on vesiputkien termistössä tavallinen putki ilman
muuntimia. Ei siis varsinaisesti mikään muunninkaan.
</p>

<p>
Muuntimia voit yhdistellä mielinmäärin:
</p>

<pre class="example">
$ grep Shemp Stooges.txt | sort | tail -n 1
1950    Studio Stoops           Shemp
</pre>

<p>
Tässä <code>grep</code> toimii lähteenä ja suodattaa <code>Stooges.txt</code>-tiedostosta kaikki
Shempin jaksot. Sitten ne lajitellaan (emme siis lajittele koko tiedostoa,
vaan sen, mitä <code>grep</code> antaa) ja lajitelluista jaksoista otamme viimeisen.
</p>

<p>
Matemaattisessa mielessä muuntimien putkittelu vastaa funktioiden
yhdistämistä. Tätä on lukionkin pitkässä matikassa käyty!
</p>
</div>
</div>
<div class="outline-4" id="outline-container-sec-1-7-3">
<h4 id="sec-1-7-3">Altaat</h4>
<div id="text-1-7-3" class="outline-text-4">
<p>
Altaat tekevät lopun yhdelle putkelle, tarjoavat päätöksen. Yleisimpiä altaita
mahtaa olla <code>less</code>, jolla voi lukea muunneltua tai muuten vain pitkää syötettä
mukavasti ohjaten syötettä. Ja <code>less</code>:n perään ei voi enää järkevästi laittaa
uusia muuntimia!
</p>

<p>
Allas voi toki tulostaa jotain tietoja annetusta syötteestä, esimerkkinä <code>wc</code>.
Tätä syötettähän voi halutessaan käyttää uutena lähteenä, ja jatkaa
putkittelua. Altaiden määritteleminen on siis hyvin epäselvää.
</p>

<p>
Eniten käytetty toiminto on varmasti syötevirran ohjaaminen tiedostoon.
Oletuksenahan syötevirta ohjautuu näytölle: tästä shelli pitää huolta. Shellit
tarjoavat kaksi tapaa tallentaa syötevirta tiedostoon: <code>&gt;</code> ja  <code>&gt;&gt;</code>.  Näillä
on selkeä ero, jota ei kannata unohtaa!
</p>

<p>
Yksi väkänen, <code>&gt;</code> ohjaa tiedostoon ja tyhjentää sen ensin puhtaaksi. Siis mikä
tahansa tiedosto, mihin ohjataan, tulee tyhjenemään täysin.
</p>

<p>
Kaksi väkästä, <code>&gt;&gt;</code>, ohjaa samalla tavalla tiedostoon, mutta lisää tiedoston
loppuun. Eli tämä versio säästää tiedoston vanhat sisällöt. Kummassakin
tapauksessa luodaan uusi, tyhjä tiedosto jos nimellä ei ennestään löytynyt
mitään.
</p>

<p>
Esimerkkiä:
</p>

<pre class="example">
$ grep Shemp Stooges.txt | sort | tail -n 1 &gt; katsomista/päivän_stooges.txt
$ cat katsomista/päivän_stooges.txt
1950    Studio Stoops           Shemp
$ grep Curly Stooges.txt | sort | tail -n 1 &gt;&gt; katsomista/päivän_stooges.txt
$ cat katsomista/päivän_stooges.txt
1950    Studio Stoops           Shemp
1946    Monkey Businessmen      Curly
</pre>

<p>
Nyt yksi väkänen varmistaa sen, että <code>päivän_stooges.txt</code> on tyhjä. Kuitenkin
kakkosgrepin aikana haluamme <b>lisätä</b> katsomislistalle toisen jakson, joten
käytämme tuplaväkäsiä.
</p>

<p>
Kun tietovirtaa on näin ohjattu tiedostoon, ei se tulosta näytölle mitään.
Voimme siis päätellä, että lopullinen "allas" on aina joko jokin tiedosto tai
terminaali itse.
</p>
</div>
</div>
<div class="outline-4" id="outline-container-sec-1-7-4">
<h4 id="sec-1-7-4">Uusia muuntimia</h4>
<div id="text-1-7-4" class="outline-text-4">
<p>
Vaikka <code>grep</code>, <code>sort</code> ja kumppanit tekevät paljon puolestamme, on
vielä paljon käsittelemättä siitä, mitä muuntimilla voidaan tehdä.
Esimerkiksi voimme tehdä korvaustöitä: tekstit muuntaa toiseen
muotoon. Oikein etevä pystyy suorittamaan esimerkiksi
laskutoimituksiakin tiettyjen palstojen kanssa. Näistä muodostuu
Unix-filosofia ja palikoiden kasattavuus.
</p>

<p>
Näistä emme käy mitään syvällisiä katsauksia läpi, koska nämä ovat
valtavan monipuolisia ja pikkujuttuja täynnä olevia sovelmia.
Mainituista ohjelmista ainakin <code>sed</code> ja <code>awk</code> ovat ansainneet omia
opuksiaan, joissa sivuja on sadoittain. Esittelen muutaman tyypillisen
käyttökohteen kullekin näistä kolmesta ohjelmasta. Loput saat itse
miettiä internetin ja manpagejen avulla.
</p>
</div>

<div class="outline-5" id="outline-container-sec-1-7-4-1">
<h5 id="sec-1-7-4-1"><code>tr</code></h5>
<div id="text-1-7-4-1" class="outline-text-5">
<p>
Pieni ja sievä ohjelma <code>tr</code> (transformer) muuntaa kirjainjoukkoja yhdestä
joukosta toiseen. Manuaalisivulla on lyhyt, mutta sitäkin selvempi kuvaus
kaikesta, mitä tämä tunnistaa oletuksena. Muunnin ottaa vastaan
kirjainjoukkoja, ja muuntaa ne vastaaviksi kirjaimiksi toisesta joukosta.
Esimerkki valaiskoon:
</p>

<pre class="example">
$ echo "Hei maailma" | tr 'a-z' 'A-Z'
HEI MAAILMA
</pre>

<p>
Muunnamme <code>tr</code>:n avulla kaikki kirjaimet joukosta <code>a-z</code> joukkoon <code>A-Z</code>, eli
toisin sanoen isoiksi kirjaimiksi. <code>tr</code> tunnistaa joitain useinkäytettyjä
joukkoja entuudestaan, joten niitä kannattaa käyttää selvyyden vuoksi aina kun
mahdollista:
</p>

<pre class="example">
$ echo "tililläni on 12,29 euroa" | tr '[:digit:]' 'x'
tililläni on xx,xx euroa
</pre>
</div>
</div>
<div class="outline-5" id="outline-container-sec-1-7-4-2">
<h5 id="sec-1-7-4-2"><code>sed</code></h5>
<div id="text-1-7-4-2" class="outline-text-5">
<p>
Ensimmäinen isompi editorimme on armas <code>sed</code>, eli <b>stream editor</b>.
"Stream" on tässä yhteydessä nyt tietovirtaa, kuten olemme puhuneet
kappaleessa. Hauska ohjelma, jolla on julmetusti käyttöä mitä
mielenkiintoisimmissa kohteissa. Tavallisesti <code>sed</code>:iä käytetään
simppeleihin <b>search-replace</b>-operaatioihin:
</p>

<pre class="example">
$ echo "tililläni on 12,29 euroa" | sed -e "s/on/ei ole/g"
tililläni ei ole 12,29 euroa
</pre>

<p>
Ideana on siis, että kullekin syötevirran riville sovelletaan joukkoa
erilaisia tekstinkäsittelykomentoja. Nämä komennot ovat peräisin
vanhasta editorista <code>ed</code>, mutta niitä on vähän paranneltu tähän
käyttöön sopivaksi! Näitä komentoja ovat klassinen <code>s</code>, eli
<b>substitute</b>. Sille annetaan ensin haettavat merkkijonot, ja sitten
sille annetaan korvaava teksti. Erotinmerkit tulee muistaa laittaa
mukaan! Viimeinen <code>g</code>-kirjain ilmaisee, että haluamme hakea rivin
kaikki ilmentymät sanasta "on": ilman geetä vain ensimmäinen on-sana
korvataan.
</p>

<p>
<code>sed</code> noin yleisesti ottaen osaa tehdä kaiken saman, mitä <code>tr</code>:kin:
</p>

<pre class="example">
$ echo "tililläni on 12,29 euroa" | sed -e "s/[[:digit:]]/x/g"   
tililläni on xx,xx euroa
</pre>

<p>
Koska <code>sed</code> käyttää monipuolisempia säännöllisiä lausekkeita, on merkkiryhmien
käyttäminen hieman erilaista kuin <code>tr</code>-esimerkissämme.
</p>

<p>
<code>sed</code> osaa myös jäljitellä <code>grep</code>:in toimintaa. Ja myös käänteisen grepin.
Esimerkiksi voimme jättää Shempin jaksot pois Stooges-listauksestamme:
</p>

<pre class="example">
$ sed -e "/Shemp/d" Stooges.txt
Vuosi   Jakso                   Kuka?
--------------------------------------------
1940    From Nurse To Worse     Curly
1958    Quiz Whiz               Joe
1935    Uncivil Warriors        Curly
1946    Monkey Businessmen      Curly
1942    Three Smart Saps        Curly
</pre>

<p>
Sama efekti siis kuin <code>grep -v</code>:n kanssa.
</p>

<p>
Kun emme ole tekemässä search-replacea (eli substituutiota), niin olemme
käyttämässä yllä esiteltyä muotoa <code>/pattern/komento</code>. Tässä tapauksessa
komento on <code>d</code>, eli <b>delete</b>. Peruskäyttöä ajatellen <code>sed</code> on parasta jättää
tähän substituointiin. Sopivia käyttökohteita toki löytyy vaikka millä
mitalla, mutta erikoisaiheet sopinee luettavaksi omista kirjoistaan.
</p>
</div>
</div>
<div class="outline-5" id="outline-container-sec-1-7-4-3">
<h5 id="sec-1-7-4-3"><code>awk</code></h5>
<div id="text-1-7-4-3" class="outline-text-5">
<p>
Hyvin hyödyllinen ohjelma on <code>awk</code>, kun käsittelemme taulukkomuotoista
dataa. Tämä <code>awk</code> kun ottaa syötteensä riveinä, ja jakaa ne soluiksi.
Näillä soluilla voidaan tehdä sitten hyvin paljon erilaisia
operaatioita: Awk on hyvin monipuolinen kieli, joka on käytännössä
kevennetty Perl, hyvin C-sukuinen kieli.
</p>

<p>
Käyttämämme esimerkkitiedosto <code>Stooges.txt</code> on toisaalta <code>awk</code>:lle
hankalaa syötettä, koska jaksojen nimet menevät sekaisin helposti.
Mutta jos haluamme kaivaa vaikkapa vuosilukujen listauksen, niin <code>awk</code>
on kätevä:
</p>

<pre class="example">
$ awk '{print $1}' Stooges.txt  |tail -n 4
1950
1948
1947
1942
</pre>

<p>
<code>awk</code>:ssa kenttiin viitataan <code>$numero</code> -merkinnällä. "Nollas" kenttä on koko
rivi sellaisenaan. Viimeinen kenttä rivillään on <code>$NF</code>. Voisimme katsoa siten
Stoogesien vaihtelevat nimet tällä tavalla:
</p>

<pre class="example">
$ tail -n +3 Stooges.txt|awk '{print $NF}'
Shemp
Curly
Joe
Curly
Curly
Shemp
Shemp
Shemp
Curly
</pre>

<p>
Tärkein <code>awk</code>-komento on luonnollisesti <code>print</code>. Helppoa on myös yhdistellä
kenttiä ja muotoilla tulostusta kuten haluaa:
</p>

<pre class="example">
$ tail -n +3 Stooges.txt|awk '{print $1 ", " $NF}'
1950, Shemp
1940, Curly
1958, Joe
1935, Curly
1946, Curly
1950, Shemp
1948, Shemp
1947, Shemp
1942, Curly
</pre>

<p>
Awk on peto kaikenlaisen CSV-muotoillun datan kanssa. Se osaa myös laskea
asioita yhteen, joten se on hyvin sulava työkalu mihin tahansa, missä on
selkeästi määriteltyä taulukko- tai listatavaraa. Oletetaan seuraavanlaista
yksinkertaista CSV-dataa:
</p>

<pre class="example">
$ cat data.csv
2008, 45, -120
2009, 80, -25
2010, 100, -10
2011, 120, -15
</pre>

<p>
Awk oletuksena halkoo rivit tyhjien merkkien (välit ja tabit) perusteella,
mutta voimme asettaa kenttäerottimen <code>-F</code> -optiolla. Ensin vähän lämmitellään
kaivamalla pelkät vuosiluvut esille tiedostosta:
</p>

<pre class="example">
$ awk -F, '{print $1}' data.csv
2008
2009
2010
2011
</pre>

<p>
Huomaa pilku option perässä. Se on se erottimemme! Awk osaa laskea lukuja
yhteen:
</p>

<pre class="example">
$ awk -F, '{print $1 $2 $3 " = " ($2+$3)}' data.csv
2008 45 -120 = -75
2009 80 -25 = 55
2010 100 -10 = 90
2011 120 -15 = 105
</pre>

<p>
Nyt tulostetaan kentät 1, 2 ja 3. Sitten tulostetaan vähän tekstiä ja tehdään
laskusuoritus, jonka tulos myös tulostetaan. On se automaattinen
tietojenkäsittely hienoa.
</p>

<p>
Awk:n alla on vahva koneisto, joka voi kerätä tietoa ja koostaa siitä
loppuun vaikkapa summan:
</p>

<pre class="example">
$ awk -F, '{saldo += ($2+$3)} END{print saldo}' data.csv
175
</pre>

<p>
Taikasanan END alle voi kääriä tehtäviä, jotka awk suorittaa aivan
lopuksi. Nyt laskemme kustakin rivistä kentät 2 ja 3 yhteen, ja
lisäämme ne muuttujaan <code>saldo</code>. Lopussa tulostamme tämän muuttujan
sisällön näkyville. Käyttötapoja on rajattomasti. Awk tukee myös
samanlaista BEGIN-lohkoa.
</p>

<p>
Awkin kanssa kirjoitellessa kannattaa muistaa selkeyskin. Pidemmät
ohjelmat voi kirjoittaa omaan tiedostoonsa, ja ne voi syöttää awkille
option <code>-f</code> kanssa. Awk osaa niin paljon, ja se on niin
helppokäyttöinenkin. Tästä aiheesta voisi pauhata vaikka kuinka
pitkään. Mutta musiikki on lopuillaan ja yöksi kääntymään päin.
Jatkamme uusilla aiheilla tuotapikaa.
</p>
</div>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-sec-1-8">
<h3 id="sec-1-8">Komentorivi</h3>
<div id="text-1-8" class="outline-text-3">
<p>
Komentorivin hallintaan kuuluu myös taitaa sen näppäinoikotiet. Oletuksena
<code>bash</code> ja muut modernit rivit käyttävät suositusta editorista, Emacsista,
lainattuja näppäinyhdistelmiä. Niitä on hyvä osata tehokasta käyttöä varten.
</p>

<p>
Erityisesti olet ehkä jo huomannut, että ylä- ja alanuolilla voit hakea
shellin historiasta vanhoja suorittamiasi komentoja. Ei siis tarvitse
kirjoitella <code>make</code>-komentoja montaa kertaa peräkkäin, vaan voit hakea
edellisen suoritetun komennon <code>&lt;Up&gt;</code>-näppäimen avulla. Vaihtoehtoisesti voit
kelailla rivejä <code>&lt;C-n&gt;</code> (next) ja <code>&lt;C-p&gt;</code> (previous) -näppäimien avulla.
</p>

<p>
Itse rivilläkin voit tehdä kaikenlaista. Nopeasti rivin alkuun hyppääminen on
monesti tarpeen, koska komentoja pitää vaihdella (esimerkiksi <code>cd ..foobar..</code>
-komennon sijaan pitäisikin listata kyseisen hakemiston tiedostot). Se toki
onnistuu Windows-tapaan <code>&lt;Home&gt;</code>-nappulalla, mutta komentorivit tukevat
Emacsista tuttua <code>&lt;C-a&gt;</code> (alkuun) ja <code>&lt;C-e&gt;</code> (loppuun) -näppäinyhdistelmiä.
Niiden avulla on vähintäänkin kätevä loikkia.
</p>

<p>
Jos näppäimistössäsi ei olisi nuolinäppäimiä, voisit silti liikkua eteen- ja
taaksepäin (edelleen) Emacsista  lainatuilla <code>&lt;C-b&gt;</code>- ja <code>&lt;C-f&gt;</code>-näppäimillä.
Bee niin kuin <b>backwards</b> ja äf kuten <b>forwards</b>.  Voit hyppiä sanojenkin
välillä (vastaa Windowsien <code>C-left=/=C-right</code> -yhdistelmiä) vaihtamalla
kontrollin sijalle altin, eli <code>&lt;M-b&gt;</code> ja <code>&lt;M-f&gt;</code>.  Näillä liikutaan yleensä
sanojen välillä, mutta pysähdytään kaikenlaisiin erikoismerkkeihinkin. Kuten
pisteisiin tai sulkuihin. 
</p>

<p>
Rivin voit myös keskeyttää, eli jos et haluakaan suorittaa mitään ohjelmaa.
Sitä ei tarvitse backspacella pyyhkiä pois, vaan voit painaa tuttua
keskeytysnappia <code>&lt;C-c&gt;</code>, jolloin saat uuden kehotteen tilalle.
</p>

<p>
Ruudun voit tyhjentää joko <code>clear</code> -komennolla (vastaa Dossin <code>cls</code>-komentoa)
mutta valmis näppäin löytyy: <code>&lt;C-l&gt;</code>.
</p>

<p>
Erittäin ovela kikka on myös suoraan automaattisesti liittää edellisen
suoritetun komennon <b>viimeinen</b> sana osaksi nykyistä komentoa
näppäinyhdistelmällä <code>&lt;M-.&gt;</code>. Paina useita kertoja kierrättääksesi eri
komentojen viimeisiä argumentteja:
</p>

<pre class="example">
$ ls auto
...
$ ls foo/bar
...
$ cd &lt;M-.&gt;   =   cd foo/bar
$ cd &lt;M-.&gt;   =   cd auto
</pre>

<p>
Tällä tavalla saat säästettyä paljon näppäilysormiasi!
</p>
</div>

<div class="outline-4" id="outline-container-sec-1-8-1">
<h4 id="sec-1-8-1">Automaattitäydennys</h4>
<div id="text-1-8-1" class="outline-text-4">
<p>
Tiedostojen ja hakemistojen nimiä ei sinun tulisi juuri koskaan kirjoittaa
käsin kokonaan. Pitkästä nimestä riittää kirjoittaa vain vähän alkua ylös ja
painamalla <code>&lt;Tab&gt;</code>-näppäintä shell tekee puolestasi paljon. Käytä tätä aina
kun mahdollista! Huomaat samalla, jos olet etsimässä tiedostoa väärästä
paikasta – mikä ei löydy tabitäydennyksellä, ei yleensä olekaan olemassa. Tai
se ei ainakaan näy bashille. Se voi siis huomauttaa jo etukäteen sinua, että
nyt on typotettu jossain.
</p>

<p>
Sekä bash että zsh tukevat myös paljon muita täydennettäviä juttuja.
Esimerkiksi yleisimpien ohjelmien asetusflagit ja sen sellaiset ovat monesti
täydennettävissä. Tämä vaatii erillistä logiikkaa, jota yleensä pluginien
muodossa lisätään shellin jatkeeksi. Näitä voi itsekin kirjoitella, mutta
kyseessä on edistynyt tekniikka, johon voin vain suositella manuaaleja ja
muuta kirjallisuutta.
</p>
</div>
</div>
<div class="outline-4" id="outline-container-sec-1-8-2">
<h4 id="sec-1-8-2">Haku historiasta</h4>
<div id="text-1-8-2" class="outline-text-4">
<p>
Eräs tärkeimpiä ominaisuuksia on shellin kyky muistaa jo suoritettuja
komentoja, jotta niitä ei aina tarvitse kirjoittaa aina alusta. Edellä
kävimme jo alkeellisimman tavan selata historiaa, eli ylä- ja
alanuolet. On kuitenkin nopea keino hakea hyvinkin kaukaisia
komentoja, jos niistä muistetaan jotain. Voimme nimittäin hakea
historiasta.
</p>

<p>
Tämä menetelmä on niinsanottu <b>reverse incremental search</b> ja se on
oletuksena kytketty helppohakuiseen näppäinyhdistelmään <code>&lt;C-r&gt;</code>.
Oletetaan, että olet joskus kauan aikaa sitten komentanut jonkin
monimutkaisen ja vaikean komennon, ja nyt haluat suorittaa saman
uudestaan. Voit joko naputella sen kokonaan uusiksi (huono), tai
naputella ylänuolta todella pitkään kunnes oikea osuma löytyy (aika
huono), tai sitten voit etsiä historiasta komentamalla <code>&lt;C-r&gt;scp</code>, ja
yllättäen bash ehdottaakin jo sinulle jotain komentoa, jonka olet
aikaisemmin suorittanut, ja jossa esiintyy sana <code>scp</code>, joka on
sattumoisin tiedostonsiirto-ohjelma.
</p>

<p>
Tätä komentoa kannattaa opetella käyttämään. Käytä komentoa <code>history</code>
tehdäksesi listaa viimeaikoina suoritetuista komennoista ja sitten
voit ottaa jonkin sieltä malliksi, jonka 'koetat' hakea. Haun voi
keskeyttää <code>&lt;C-c&gt;</code>:llä ja ehdotetun komennon voi toki suorittaa
enteriä näpyttämällä.
</p>
</div>
</div>
<div class="outline-4" id="outline-container-sec-1-8-3">
<h4 id="sec-1-8-3">Editoi riviä isommin</h4>
<div id="text-1-8-3" class="outline-text-4">
<p>
Komentoriviä ei tarvitse välttämättä editoida ollenkaan paikanpäällä,
jos et halua. Ainakin bash tukee näppäinyhdistelmää <code>&lt;C-x&gt;&lt;C-e&gt;</code>,
jolla nykyisen komentorivin sisältö otetaan ylös tiedostoon ja
käynnistetään vapaavalintainen editori. Editorissa voit pyöritellä
komentoriviä kuten mieli tekee, ja lopuksi tallennat ja suljet
editorin. Siinä kohtaa shell tulee väliin ja suorittaa kyseisen
tiedoston sisällön.
</p>

<p>
Tämä menetelmä on erityisesti pidempien litanioiden, kuten vaikkapa
<code>for</code>-silmukoiden, hienosäätöön soveltuva työkalu. Editorissa ei
välttämättä saa hyvää tabitäydennystä pikkujutuille, joten tarpeesta
riippuen valitse sopiva työkalu sopivaan ongelmaan.
</p>
</div>
</div>
<div class="outline-4" id="outline-container-sec-1-8-4">
<h4 id="sec-1-8-4">Jatkoon</h4>
<div id="text-1-8-4" class="outline-text-4">
<p>
Näillä perusteilla pääset jo pitkälle, mutta matka ei ole edes
kunnolla alkanut. Voit nimittäin komentorivillä tehdä aivan valtavat
määrät sellaista editointia, johon ei edes Wördillä pystyisi. Tutustu
<code>bash</code>:n ohjeisiin (<code>man bash</code>, kts Manpageista kertova osio) ja
tutustu mm. seuraaviin ominaisuuksiin:
</p>

<ul class="org-ul">
<li>leikkaa ja kopioi komentorivillä
</li>
<li>luo näppäilymakroja eliminoimaan puuduttavia näppäinyhdistelmiä
</li>
<li>käännä tekstiä isolla tai pienellä kirjoitetuksi yhden näppäinyhdistelmän
voimin
</li>
<li>kumoa, tai tee uudestaan muutoksia
</li>
<li>käännä kirjainten tai sanojen paikkaa rivillä yhden yhdistelmän voimin
</li>
</ul>

<p>
Totisesti. Suuri osa isojen editorien (Emacs, vi) kapasiteetista on siirretty
myös suoraan komentoriville käsiteltäväksi, vaikka tarvetta on hyvin harvoin.
Itse ainakin suosin mieluummin siirtymistä omaan editoriin kuin yrittäisin
kaiken tehdä rivillä suoraan.
</p>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-sec-1-9">
<h3 id="sec-1-9">Pakkaus ja purkaminen</h3>
<div id="text-1-9" class="outline-text-3">
<p>
Winzipit ja -rarit ovat kivoja ohjelmia, mutta eivät oikein toimi ilman
graafista ympäristöä. Erityisesti ongelmallista on päivitysten hakeminen
veppipalveluihinsa, jos ainut tuntemansa keino on lähetellä tiedostot
yksitellen kotikoneeltansa palvelimelle. Se on hidasta ja voi tuottaa uusia
ongelmia esimerkiksi väärien tai hankalien oikeuksien kanssa.
</p>

<p>
Unixeissa yleisin tapa koostaa useita tiedostoja yhteen tiedostoon on <code>tar</code>,
eli <b>terva</b>. Useinhan toisiinsa tervatut esineet tuppaavat pysyäkin yhdessä.
Tätä varten on ohjelma <code>tar</code>, jolla tehdään niinsanottuja tervapalloja
<b>tarball</b>. Päätteenä käytetään yleensä <code>.tar</code>-päätettä. Toisin kuin Dos- ja
Windows-maailmasta tuttu <code>ZIP</code>-formaatti, tervapallot eivät ole millään
tavalla pakattuja tiedostoja. Yksinkertaistaen <code>tar</code> lyttää kaikki saamansa
tiedostot peräkkäin pallon muotoon.
</p>

<p>
Mutta yleensä tätä pakkaamatonta tervapalloa sitten voidaan pakata, ja
pakataankin. Unix-maailmassa nykyään suosituimmat pakkausalgoritmit (tai
ainakin pakkausohjelmat) ovat <code>gzip</code> ja <code>bzip2</code>. Näistä kumpikin vastaa noin
zip-tiedostojen pakkaustehokkuutta, bzip2:n ollessa hieman tehokkaampi. Toki
se on myös vähän hitaampi sitten vastapainoksi.
</p>

<p>
Nämä tar-tiedostot sitten pakatussa muodossa saavat yleensä
(tupla)tiedostopäätteen <code>.tar.gz</code> tai <code>.tar.bz2</code>. Joskus vanhempina aikoina
nähtiin päätteitä <code>.tgz</code> ja <code>.tbz</code> vastaavasti.
</p>
</div>

<div class="outline-4" id="outline-container-sec-1-9-1">
<h4 id="sec-1-9-1">Tarballin purkaminen</h4>
<div id="text-1-9-1" class="outline-text-4">
<p>
Kun tämmöinen pallo sitten jostain ilmoille lentää, se yleensä halutaan purkaa
pois. Ensin on viisasta tutkia, mitä se on syönyt. Puhutaan oikein
tar-pommista, jossa viattoman näköinen pieni tarball sisältää sopivannimisiä
nollamittaisia tiedostoja paljon, ja joka voi tuhota systeemin pahaa
aavistamattoman käsissä. Tähän auttaa kun ensin katsotaan, minkänimisiä
tiedostoja sieltä löytyy:
</p>

<pre class="example">
$ tar -tf TARBALL
</pre>

<p>
antaa ilmoille listan tiedostoista pallon sisältä. Pitkää listaa varten
kannattanee tuloste putkittaa <code>less</code>:ille. Voit halutessasi saada enemmän
tietoja selville tiedostoista antamalla <code>-v</code>-läpän tarrille:
</p>

<pre class="example">
$ tar -vtf TARBALL | less
</pre>

<p>
Huomiollepantavaa on, että asetuksien viivaa ei ole pakko kirjoittaa, jos
annat niitä heti komentorimpsun alussa. Toinen tärkeä huomio on, että <code>-f</code> on
<b><b>ensiarvoisen ehdoton</b></b> lähes kaikissa tapauksissa, joissa tarria yleensä
käytetään. Aina tulee määritellä tiedosto erikseen. Moni menee ainakin
luontivaiheessa vähän sekaisin asetuksien antojärjestyksestä. Sääntö on selvä:
<code>-f</code>-flagia tulee aina seurata tarballin tiedostonimi.
</p>

<p>
Nyt, miten varsinaisesti puramme tarballin? Kunhan sen sisältö on turvallisen
näköistä, voimme purkaa sen <code>-x</code> -flagin avulla. Jos (ja kun) kyseessä on
pakattu tervapallo, meidän pitää antaa joko asetus <code>-z</code> (gzip) tai <code>-j</code>
(bzip2) tarrille, jotta purkaminenkin onnistuu samalla kertaa.
</p>

<p>
<b><b>Oletuksena</b></b> tiedostot puretaan työhakemistoon, eli sinne, missä annat
komennon. Kannattaa siirtyä kohdehakemistoon, tai luoda tyhjä
väliaikaishakemisto, ettei tule sotkua. Ja purkamisesta esimerkit:
</p>

<pre class="example">
$ tar tf /tmp/testi.tar.bz2
./foo
./bar
$ ls
fez
$ tar xjf /tmp/testi.tar.bz2
$ ls
fez
foo
bar
$ tar tf /tmp/testi2.tar.gz
./FOO/auto
$ tar xzf /tmp/testi2.tar.gz
$ ls FOO
auto
</pre>

<p>
Siinäpä. Jos tarballin sisällä on alihakemistoja (kuten jälkimmäisessä
esimerkissä), niin ne luodaan kuten kuuluukin.
</p>

<p>
Voit toki halutessasi määritellä kohdehakemiston, minne <code>tar</code> purkaa
tiedostot, mikäli nykyinen työhakemisto ei kelpaa. Tämä on <code>-C</code> -flagin
heiniä:
</p>

<pre class="example">
$ tar xjf testi.tar.gz -C autot
</pre>

<p>
Jos tiedostojen alkuperäiset oikeudet ovat tärkeät, käytetään <code>-p</code> -asetusta
(preserve permissions). Tämä voi joissain web-sovelluksissa olla tärkeä.
</p>

<p>
Tarballista voit myös purkaa vain osan tiedostoista. Tämä on aika työlästä
ihmisen kirjoiteltavaksi, mutta jos tiedät tarkan tiedostonimen (helpoiten
kopioitavissa <code>tf</code>-tulosteesta), niin voit antaa sen komennon loppuun. Tar
tulee purkamaan vain sen tiedoston. Myös erilaiset jokerimerkit onnistuvat
tietyissä puitteissa, tutustu tarin manpageihin.
</p>

<p>
Jos saamasi paketti loppuu päätteeseen <code>.tar</code>, voi olla, että sitä ei ole
pakattu millään. Voit ensin koettaa <code>file</code>-ohjelman avulla tutkia
pakkaamattomuutta. Tai sitten voit kokeilla ensin <code>-z</code>-flagin kanssa purkaa.
Gzip on kuitenkin se yleisempi tapa pakata. Tar kyllä ilmoittaa kovaäänisesti,
jos valitsemasi purkumenetelmä ei tepsi.
</p>
</div>
</div>
<div class="outline-4" id="outline-container-sec-1-9-2">
<h4 id="sec-1-9-2">Pakkaaminen, eli tarballien luominen</h4>
<div id="text-1-9-2" class="outline-text-4">
<p>
Käytämme purkuflagin sijaan <code>-c</code> (create) -flagia. Edelleen flagi <code>-f</code> on
oltava! Lista tiedostoista annetaan lopussa rimpsuna. Voit antaa yksittäisiä
tiedostonimiä tai sitten hakemistoja, tai useita hakemistoja. Tai erilaisia
kokonaisuuksia. Esimerkki valaisee parhaiten:
</p>

<pre class="example">
# työntää koko hakemiston autot pakettiin
$ tar cjf paketti.tar.bz2 autot/
# luennot-paketti sisältää maanantain ja tiistain materiaalit.
$ tar czf luento.tar.gz luennot/ma.pdf luennot/ti.pdf
</pre>

<p>
Edelleen <code>-p</code> toimii, jos tiedostojen oikeudet ovat merkitykselliset. Kuten
huomaat, voit valita pakkaustavan samoilla asetuksilla kuin purettaessa. Ja
tiedostonimi on määrättävä. Jos se tuntuu luontevammalta, voi toki paketin
nimen antaa vasta viimeisenä näin:
</p>

<pre class="example">
$ tar cj pe.pdf la.pdf -f pitkäviikonloppu.tar.bz2
</pre>
</div>
</div>
<div class="outline-4" id="outline-container-sec-1-9-3">
<h4 id="sec-1-9-3">Entä zipit?</h4>
<div id="text-1-9-3" class="outline-text-4">
<p>
Vaikka <code>tar</code> onkin Unix-puolen <b>de facto</b> -pakkausmuoto, on joskus avattava
niitä zippejäkin. Useimmissa Unix-systeemeissä on ohjelma <code>zip</code> pakkaamaan ja
<code>unzip</code> purkamaan zip-tiedostoja.
</p>

<p>
Kuten odottaa saattaa, samanlaiset toiminnot löytyvät täältäkin kuten tarrin
ympäriltä. Nämä esimerkit nyt valaiskoot tarpeeksi.
</p>

<dl class="org-dl">
<dt> Listaus </dt><dd><code>unzip -l autot.zip</code>
</dd>
<dt> Pura tänne </dt><dd><code>unzip autot.zip</code>
</dd>
<dt> Pura muualle </dt><dd><code>unzip autot.zip -d Autot</code>
</dd>
<dt> Pakkaus </dt><dd><code>zip autot.zip Mersu.png Bmw.jpeg</code>
</dd>
</dl>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-sec-1-10">
<h3 id="sec-1-10">Haku päällä</h3>
<div id="text-1-10" class="outline-text-3">
<p>
Eli miten hakea ja löytää tiedostoja tietokoneelta. Tarkastelemme
kaksi yleisintä menetelmää etsiä tiedostoja. Toinen on indeksoiva
haku, eli se on nopea tapa hakea, mutta sen pitää koostaa listaa
kaikista tiedostoista jossain siistissä muodossa. Indeksointi vie
aikaa ja käytetty indeksi on yleensä vähintäänkin tunteja vanha.
</p>

<p>
Toinen tapa on hitaampi malli, jossa käydään järjestelmällisesti
kaikki läpi ja palautetaan osumat listamuodossa. Se ei käytä
indeksointia, eli on aina ajantasalla. Lisäksi voimme tehdä
erikoisempiakin vertailuja ja peräti jotain pientä automatisointia,
jolla helpotamme ylläpitotehtäviä.
</p>
</div>

<div class="outline-4" id="outline-container-sec-1-10-1">
<h4 id="sec-1-10-1"><code>locate</code></h4>
<div id="text-1-10-1" class="outline-text-4">
<p>
Nopea <code>locate</code> sopii käytettäväksi silloin kun:
</p>

<ul class="org-ul">
<li>ei tiedetä, missä päin systeemiä tiedosto mahtaa majailla
</li>
<li>haetaan tiedostoja vain nimen perusteella
</li>
</ul>

<p>
Ohjelmaa on helppo käyttää:
</p>

<pre class="example">
$ locate clojure
... iso lista tiedostoja, joiden nimessä tai 
... hakemistopolussa esiintyy sana 'clojure'
</pre>

<p>
Tärkeätä on huomata, että kirjainkoolla on jälleen väliä! Käyttäkäämme yleistä
optiota <code>-i</code> poistamaan tämä epäkohta. Tärkeämpi ominaisuus on käyttää
säännöllisiä lausekkeita (flagi <code>-r</code>) hakemaan esimerkiksi tietynpäätteisiä
tiedostoja:
</p>

<pre class="example">
$ locate -ir "clojure.*pdf"
.../share/apps/RecentDocuments/Programming_Clojure.pdf.desktop
/home/progo/kirjallisuutta/ClojureinAction.pdf
/home/progo/kirjallisuutta/Programming_Clojure.pdf
/home/progo/kirjallisuutta/TheJoyofClojure.pdf
.../Viestintä/paperit/Multicore_parallelization_in_Clojure.pdf
</pre>

<p>
Esimerkin hakupatterni on usein riittävä tapa rajata tuloksia vain
PDF-tiedostoihin, mutta ollaksemme täydellisiä hakuteksti pitäisi päättää
<code>$</code>-merkillä, joka merkitsee rivin loppumista:
</p>

<pre class="example">
$ locate -ir "clojure.*pdf$"
/home/progo/kirjallisuutta/ClojureinAction.pdf
/home/progo/kirjallisuutta/Programming_Clojure.pdf
/home/progo/kirjallisuutta/TheJoyofClojure.pdf
.../Viestintä/paperit/Multicore_parallelization_in_Clojure.pdf
</pre>

<p>
Tässäpä kaikki oleellinen, mitä <code>locate</code>:n kanssa voi tehdä. Säännöllisten
lausekkeiden alkeet kannattaa tuntea, jotta haun karsiminen helpottuu
oleellisesti. Yleisesti Unix-systeemeissä on kymmeniä tuhansia tiedostoja, ja
yleisillä hakusanoilla tuloksia tulee aika paljon. Siitäkin syystä seuraava
<code>find</code> on paikoin näppärämpi tapa hakea.
</p>
</div>
</div>
<div class="outline-4" id="outline-container-sec-1-10-2">
<h4 id="sec-1-10-2"><code>find</code></h4>
<div id="text-1-10-2" class="outline-text-4">
<p>
Hakeminen voi olla hidasta <code>find</code>:iä käytettäessä, mutta <code>find</code> omaa
takataskussaan paljon tehokkaita toimintoja. Tutkitaanpa vähän
ohjelman mahdollisuuksia vähän kerrassaan.
</p>

<p>
Huonoin tapa, miten <code>find</code>:iä voi käyttää, on panna se <code>locate</code>:n
huonoksi tuuraajaksi:
</p>

<pre class="example">
$ find / -iname '*clojure*pdf'
/home/progo/kirjallisuutta/ClojureinAction.pdf
/home/progo/kirjallisuutta/Programming_Clojure.pdf
/home/progo/kirjallisuutta/TheJoyofClojure.pdf
.../Viestintä/paperit/Multicore_parallelization_in_Clojure.pdf
</pre>

<p>
Erona on, että tämä haku vie oletettavasti paljon enemmän aikaa
(SSD-kovalevylliset systeemit ehkäpä onnekkaasti selviävät tästäkin
nopeasti). Kirjoittamistakin on enemmän. Hyvänä puolena ehkäpä se,
ettei säännöllisiä lausekkeita tarvitse osata kirjoittaa. Nyt riittää
<code>bash</code>-shellissäkin tutut kaksi jokerimerkkiä, eli <code>*</code> ja <code>?</code>. Ja jos
hakuteksti päättyy johonkin niin se sitten päättyy johonkin.
Hakutekstin alku merkitsee tässä tapauksessa tiedostonimen alkua, eli
jos et ole varma, että hakusanasi aloittaa tiedostonimen, laita tähti
varmuuden varalta aivan alkuun.
</p>

<p>
Yleinen muoto on:
</p>

<pre class="example">
$ find &lt;hakemisto&gt; -name 'hakusana'
</pre>

<p>
tai:
</p>

<pre class="example">
$ find &lt;hakemisto&gt; -iname 'kirjainkooton hakusana'
</pre>

<p>
Jälkimmäinen, eli iin sisältävä <code>-iname</code> on taas se kirjainkoon
huomiottajättävä versio. Yleisempi näin. Huomattavaa on, että
hakemisto pitää antaa, tai jos ei anna, niin <code>find</code> olettaa
työhakemiston (joka on sama kuin <code>.</code>).
</p>

<p>
Pelkkä <code>find</code> ilman mitään argumentteja listaa kaikki tiedostot, mitä
se löytää työhakemistosta alaspäin. Jokainen argumentti on siis
eräänlainen rajoitin, filtteri (kuten <code>grep</code>) listan karsimiseksi.
</p>

<p>
Listataan erilaisia hakumääreitä, joita <code>find</code> voi käyttää listan
rajoittamiseksi:
</p>

<table frame="hsides" rules="groups" cellpadding="6" cellspacing="0" border="2">


<colgroup>
<col class="left"></col>

<col class="left"></col>
</colgroup>
<thead>
<tr>
<th class="left" scope="col">Hakumääre</th>
<th class="left" scope="col">mitä haetaan</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>-type f</code></td>
<td class="left">vain tiedostot</td>
</tr>

<tr>
<td class="left"><code>-type d</code></td>
<td class="left">vain hakemistot</td>
</tr>

<tr>
<td class="left"><code>-type l</code></td>
<td class="left">vain symboliset linkit</td>
</tr>

<tr>
<td class="left"><code>-name n</code></td>
<td class="left">tiedostonimellä <b>n</b> (kirjainkoko!)</td>
</tr>

<tr>
<td class="left"><code>-iname n</code></td>
<td class="left">tiedostonimellä <b>n</b> (ei kirjainkokoa)</td>
</tr>

<tr>
<td class="left"><code>-regex r</code></td>
<td class="left">tiedostonimellä <b>r</b> (säännöllinen lauseke)</td>
</tr>

<tr>
<td class="left"><code>-size n</code></td>
<td class="left">kooltaan <b>n</b> olevat tiedostot</td>
</tr>

<tr>
<td class="left"><code>-empty</code></td>
<td class="left">vain tyhjät tiedostot/hakemistot</td>
</tr>

<tr>
<td class="left"><code>-writable</code></td>
<td class="left">kirjoitettavat tiedostot</td>
</tr>

<tr>
<td class="left"><code>-readable</code></td>
<td class="left">luettavat tiedostot</td>
</tr>

<tr>
<td class="left"><code>-executable</code></td>
<td class="left">suoritettavat tiedostot</td>
</tr>

<tr>
<td class="left"><code>-group grp</code></td>
<td class="left">tiedostot, jotka kuuluvat ryhmään <b>grp</b></td>
</tr>

<tr>
<td class="left"><code>-owner own</code></td>
<td class="left">tiedostoja, jotka kuuluvat käyttäjälle <b>own</b></td>
</tr>

<tr>
<td class="left"><code>-atime n</code></td>
<td class="left">tiedostot, joita on käytetty <b>n</b> päivää sitten*</td>
</tr>

<tr>
<td class="left"><code>-ctime n</code></td>
<td class="left">tiedostot, jotka on luotu <b>n</b> päivää sitten*</td>
</tr>
</tbody>
</table>

<p>
Tässä eivät edes olleet kaikki mahdolliset hakumääreet. Kokoa haettaessa
pätevät säännöt:
</p>

<pre class="example">
$ find -size +10k     # kaikki yli 10-kilotavuiset tiedostot
$ find -size -1M      # kaikki alle megaiset
$ find -size 123c     # kaikki tasan 123-tavuiset
</pre>

<p>
Päivämääriä tarkasteltaessa <code>+0</code> tarkoittaa kaikkia yli vuorokausi sitten
tehtyjä muutoksia ja <code>+1</code> on vastaavasti yli kaksi vuorokautta sitten.
</p>

<p>
Näitä edelläolevia voi matemaattisen logiikan rajoissa yhdistellä, tarkat
tiedot: <code>man find</code>:
</p>

<pre class="example">
$ find \( -iname 'foo' -size 100k \) -o -name 'bar'
</pre>

<p>
Hakee joko <b>foo</b>-nimiset tiedostot, joiden koko on tasan 100 kilotavua ja
lisäksi <b>bar</b>-nimiset. Suluilla voit vaikuttaa järjestykseen.
</p>

<p>
Näiden ehtojen lisäksi <code>find</code> voidaan laittaa tekemään löydetyille
tiedostoille jotain erikoistoimia (manuaalista alaosio <b>ACTIONS</b>). Muutamia
yleisesti käytettyjä:
</p>

<pre class="example">
$ find . -name '*temp*'     -delete     # poista 
$ find /tmp -iname '*demo*' -ls         # listaa tarkemmat tiedot
$ find . -iname '*todo*' -exec 'mv {} ~/TEE/ ;' # siirrä hakemistoon ~/TEE
</pre>

<p>
Erityisesti viimeinen, eli vapaamuotoisen komennon suorittava <code>-exec</code> on
tehokas pirulainen. Sille voi antaa minkä tahansa tavallisen komennon, jossa
operoitavan tiedostonimen tilanne kirjoitetaan aaltosulut <code>{}</code>. Find täydentää
siihen kohtaan löytyneiden tiedostojen nimet, ja suorittaa komennon. Tästä
löytyy vastaava versio <code>-ok</code>, joka on kuten <code>-exec</code>, mutta kysyy käyttäjältä
varmistuksen <b>jokaisen</b> löytyneen tiedoston kohdalla. Sopiva joihinkin
poistotilanteisiin. Käytettäessä <code>-exec</code> -komentoa täytyy se päättää
puolipisteeseen, jotta <code>find</code> voi varmistua komennon täydellisyydestä. Ja
muutenkin yleensä koko komento on viisainta kääriä yksittäisiin hipsuihin
<code>''</code>, jotta suorittava shell ei tee omia muutoksiaan erikoismerkkeihin.  Siitä
syystä esimerkiksi tähtiä sisältävät hakutekstit on käärittävä
lainausmerkkeihin, ettei <code>bash</code> pääse itse täydentämään nimiä auki.
</p>

<p>
Find-ohjelman manuaalisivut ovat esimerkilliset esimerkkien ja selkeyden
suhteen, joten sieltä kannattaa jatkaa lukemistaan. Tämä ohjelma se totisesti
osaa tehdä yhtä sun toista.
</p>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-sec-1-11">
<h3 id="sec-1-11">Toistorakenteista</h3>
<div id="text-1-11" class="outline-text-3">
<p>
Tässä luvussa puhelemme joitain alkeita toistuvista operaatioista,
joilla sujuvoitat työtä useiden samankaltaisten tiedostojen parissa.
</p>
</div>

<div class="outline-4" id="outline-container-sec-1-11-1">
<h4 id="sec-1-11-1">Kertaus jokereista</h4>
<div id="text-1-11-1" class="outline-text-4">
<p>
Kuten varmasti tiedämmekin jo, useimmat ohjelmat pystyvät käsittelemään useita
tiedostoja samalta komentamalta. Esimerkiksi seuraavat kaksi sarjaa ovat
samat:
</p>

<pre class="example">
$ rm toisto.txt bmw.jpeg
</pre>

<pre class="example">
$ rm toisto.txt
$ rm bmw.jpeg
</pre>

<p>
Mutta mitä on tarkalleen ottaen komentaa <code>rm *.txt</code>? Ehkä muistanemme, että
<code>rm</code> tai mikään muukaan ohjelma varsinaisesti ei itse tee asteriskin
aukipurkamista. Sen tekee shell:
</p>

<pre class="example">
$ ls
a
b
c

$ echo kaikuu...
kaikuu...

$ echo *
a b c
</pre>

<p>
Jos komentaisimme tässä hakemistossa <code>rm *</code>, niin shell tekee asteriskin
purkamisen ensin pois, ja sitten vasta kutsuu käskytettäviä ohjelmia.
Edellisessä esimerkissä kaiutettiin <code>echo</code>-ohjelman avulla kaikki annetut
argumentit sellaisenaan takaisin. Näemme, että <code>bash</code> on tehnyt tehtävänsä
purkaessaan auki tähden.
</p>

<p>
Asteriski eli tähtihän tarkoitti mitä tahansa lukumäärää merkkejä (eli
nolla merkkiä tai enemmän). Kysymysmerkki korvaa mielivaltaisen yhden merkin.
Miksikö asteriski korvaa myös nolla merkkiä? Vaikka dosissa asia oli toisin,
unixeissa on usein tiedostoja ilman päätteitä, ja on kiva käyttää asteriskia
niiden, sekä päätteellisten että päätteettömien, hakemiseen:
</p>

<pre class="example">
$ ls
foobar.txt
teksti.txt
teksti.txt.bak
kauppa.doc
$ ls teksti.txt*
teksti.txt
teksti.txt.bak
</pre>

<p>
Hyvän Unix-käytännön mukaan kirjoitetut ohjelmat hyväksyvät aina useampia
tiedostoja samaan komentoon, jos se vain on järkevää ohjelman luonteen
kannalta. Silloin jokerimerkkejä voidaan käyttää sujuvasti shellin kautta
nopeuttamaan askareita.
</p>

<p>
Jos kuitenkin ohjelma ei syystä tai toisesta tue kuin yksittäisten tiedostojen
antamista kerrallaan, joudutaan turvautumaan toistosilmukoihin.
</p>
</div>
</div>
<div class="outline-4" id="outline-container-sec-1-11-2">
<h4 id="sec-1-11-2">Toistoa</h4>
<div id="text-1-11-2" class="outline-text-4">
<p>
Huonosti käyttäytyvien ohjelmien lisäksi on ihan hyvinkäyttäytyviäkin
ohjelmia, joissa ei sinällään ole järkeä käsitellä useita tiedostoja
kerralla. Shelleissä käytettävä <code>for</code>-rakenne on hyvin tehokas tapa
yhdistää jokerimerkkejä ja useita tiedostoja sellaisiin ohjelmiin,
jotka käsittelevät yhden tiedoston kerrallaan.
</p>

<p>
For-silmukka on moniosainen, ja kirjoitetaan usein monelle riville. Perusmalli
on seuraava:
</p>

<pre class="example">
for nimi in a b c ...
do
    # komentoja tähän, joissa käytetään nimeä $nimi
done
</pre>

<p>
Tämähän alkaa muistuttaa vähän sitä ohjelmointia, mutta ei hätää. Tässä on
kyllä monta liikkuvaa osaa, joiden kanssa pitää olla vähän tarkkana. Rakenteen
toinen sana, eli <b>nimi</b>, on vapaavalintainen muuttujanimi. Siihen muuttujaan
vaihdetaan vuorollaan uusi alkio listasta <code>a b c ...</code>. Lista voi olla
mielivaltaisen pitkä, ja alkiot erotellaan yksinkertaisesti välilyönnein.
</p>

<p>
Sen jälkeen <code>do</code>- ja <code>done</code>-komentojen väliin kirjoitellaan komentoja, jotka
mielellään hyödyntävät tätä muuttujaa. Siihen viitataan asettamalla
dollarimerkki nimen eteen.
</p>

<p>
Esimerkki toivottavasti valottaa paremmin:
</p>

<pre class="example">
$ for kuukausi in tammi helmi maalis
do 
echo "$kuukausi"kuu
done

tammikuu
helmikuu
maaliskuu
</pre>

<p>
Silmukan suoritus alkaa heti kun <code>done</code> lyödään sisään. Esitystä voi tiivistää
hieman:
</p>

<pre class="example">
$ for kuukausi in tammi helmi maalis
do echo "$kuukausi"kuu ; done
</pre>

<p>
Ajaa saman asian, mutta vain kahdella rivillä. Ketjuttaa toki saisi myös nämä
kaksi riviä asettamalla yhden puolipisteen lisää ennen <code>do</code>-lausetta.
</p>

<p>
No nyt sitten niihin jokerimerkkeihin: silmukassa voit antaa shellin muodostaa
sinulle listan, jota käytetään muuttujassa. Tavalliset jokerimerkit
riittävät:
</p>

<pre class="example">
$ ls
a
b
c
$ for tiedosto in *
 do echo "$tiedosto"
done

a
b
c
</pre>

<p>
Kas näin. Nyt suosittelen aina ympäröimään muuttujaviittaukset lainausmerkein,
koska muuten eräs merkki sotkee suoritusta aika pahasti: välilyönnit
tiedostonimissä.  Asiasta ei tarvitse erikseen tehdä mitään sääntöjä, kunhan
käyttää lainausmerkkejä aina kun käyttää jokerimerkkejä.
</p>

<p>
Otetaan käytännön esimerkki, jossa <code>for</code>-silmukoihin on turvauduttava.
Olemme ottaneet digikamerasta liudan valokuvia, ja ne kaikki pitäisi pienentää
nettijakelua varten. Tätä varten oletamme erinomaisen Imagemagick-paketin
olemassaoloa systeemissä.
</p>

<p>
Imagemagick-paketin käytetyin työkalu lienee nyt haluttu <code>convert</code>, joka
käsittelee kuvatiedostoa eritavoin. Huomioitavinta on se, että <code>convert</code>
käsittelee yhden tiedoston kerrallaan. Emme voi siis kehitellä mitään <code>convert
*</code> -sarjaa itsellemme, vaan käytämme <code>for</code>-silmukkaa apunamme. Ensin on hyvä
tutkia, miten pienentäisimme yhden yksittäisen kuvan. Kaavaa emme opettele
täyteläisesti, koska tämä ei ole kuvankäsittelyopas, mutta yleissääntönä
pienennös tehtäisiin näin (loput <code>man convert</code>):
</p>

<pre class="example">
$ convert kuva.jpg -resize 50% pienennetty.jpg
</pre>

<p>
Ensin lähdetiedosto, sitten muutostoimet, ja lopuksi kohdetiedosto. Voimme
syöttää silmukassa nyt lähdetiedoston paikalle muuttujanimen ja
kohdetiedostoja varten luomme uuden hakemiston, ettei mene mikään sekaisin.
</p>

<pre class="example">
$ ls
IMG2304.JPG
IMG2305.JPG
...
IMG2393.JPG
$ mkdir pienennetyt
$ for kuva in *.JPG
do  convert "$kuva" -resize 50% pienennetyt/"$kuva"
done
</pre>

<p>
Ja Unix-filosofia on jälleen osoittanut kyntensä.  Tekemällä ohjelman,
joka tekee yhden asian hyvin, päästään pitkälle. Ei tarvita erikseen ohjelmaa
tekemään peräkkäissuoritusta (kuten kaupallisten kuvankäsittelyohjelmien
<b>batch processing</b> -toimintoja) kun shell osaa homman. <code>convert</code>:in ei
tarvitse tietää mitään sadoista kuvista!
</p>
</div>
</div>
<div class="outline-4" id="outline-container-sec-1-11-3">
<h4 id="sec-1-11-3"><code>seq</code></h4>
<div id="text-1-11-3" class="outline-text-4">
<p>
Esitellään sivumainintana apuri <code>seq</code>, joka tekee jonoja (<b>sequence</b>).
Tavallisesti se olisi kovin tylsä ohjelma:
</p>

<pre class="example">
$ seq 1 5           # luvut 1-5
1
2
3
4
5
$ seq 2 2 10        # parilliset luvut 2-10
2
4
6
8
10
</pre>

<p>
Mutta ehkäpä arvannemme jo. Silmukoissa sillä voi olla käyttöä enemmän.
Nimittäin ohjelmien tulosteita voi käyttää <code>for</code>-silmukan listan tekemiseen:
</p>

<pre class="example">
$ for i in =seq 1 10=
do echo $i ; done
1
2
3
4
5
</pre>

<p>
Listan generoiva ohjelma kääritään takapilkkuihin (<b>backtick</b>) ja se kelpaa
<code>for</code>:lle sellaisenaan. Itse asiassa mikä tahansa muukin ohjelma kelpaa
samalla tavalla syötteentekijäksi <code>for</code>:lle. Riittää, että se ohjelma tuottaa
tyhjällä (väli, tabi tai rivinvaihto) eroteltua tekstiä. Sitä voidaan jopa
filtteröidä tavalliseen tapaan:
</p>

<pre class="example">
$ for i in =seq 100 | grep ^2= ; do echo $i ; done
2
20
21
22
23
24
25
26
27
28
29
</pre>

<p>
Eli kaikki kakkosella alkavat luvut päätyvät <code>for</code>:lle asti <code>grep</code>:in ansiosta.
</p>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-sec-1-12">
<h3 id="sec-1-12">Työnohjaus komentorivillä</h3>
<div id="text-1-12" class="outline-text-3">
<p>
Vaikka komentorivi onkin aika peräkkäismuotoinen ratkaisu, ollaan
kaukana DOS-ajoista, ja eri ohjelmia voidaan jättää taustalle ajamaan,
tai vaihdella ohjelmien välillä kuin ikkunoissa konsanaan.
</p>

<p>
Ikkunoiduissa maailmoissa voimme pienentää ikkunan taustalle, jos
pitää keskittyä toiseen ikkunaan. Jos ohjelma tekee jotain
aikaaviepää, se voi tehdä sitä taustalla aivan rauhassa. Samanlaiset
ohjausmenetelmät löytyvät komentoriviltäkin hieman alkeellisemmassa
muodossa. Seuraavassa luvussa <a href="#sec-1-13">Screen</a> sitten käsittelemme hieman
monipuolisemman tavan suorittaa moniajoa.
</p>
</div>

<div class="outline-4" id="outline-container-sec-1-12-1">
<h4 id="sec-1-12-1">Suspensio</h4>
<div id="text-1-12-1" class="outline-text-4">
<p>
Kun olet tekemässä jotain komentorivillä – vaikkapa editoimassa
tiedostoa – ja sinulle tuleekin tarve hypätä komentoriville vaikkapa
katsomaan, onko sinulle tullut uutta sähköpostia, voit toki sulkea
editorisi ja avata sähköpostisi. Tai voit <b>keskeyttää</b> editorisi,
panna se nukkumaan. Miten sitä nyt kuvailisi. Joka tapauksessa: oli se
ohjelmasi sitten jokin kokoruudun sovellus tai jokin pienempi ohjelma,
sen voi panna nukkumaan komentamalla <code>&lt;C-z&gt;</code>. Mitä seuraavaksi
tapahtuukaan: päädyt takaisin komentoriville ja ohjelmasi on nyt
nukkumatilassa.
</p>

<p>
Nyt voit puuhastella sähköpostisi tai minkä tahansa tehtävän parissa.  Tässä
tilassa (<b>suspended</b>) se ohjelma ei tee mitään, eli ei varsinaisesti suorita
mitään. Jos sille jäi homma kesken, niin se homma on pysähdyksissä.
</p>

<p>
Kun olet valmis palaamaan ohjelmasi pariin, voit komentaa <code>fg</code>, eli
(<b>foreground</b>) tuodaksesi ohjelman takaisin etualalle. Onkos sinulla
vaihtoehtoja? Kyllä on – jos ohjelmasi on jokin sellainen, joka ei kaipaa
käyttäjän huomiota, voit laittaa sen suorittumaan taka-alallekin. Tällöin
komento on luonnollisesti <code>bg</code> (<b>background</b>).
</p>

<p>
Tausta-ajoon suunnattuja ohjelmia on aika paljonkin, esimerkiksi kaikki
graafiset ohjelmat ovat sen terminaalin kannalta aika tausta-ajoisia. Voit
laittaa sovelluksen suorittumaan <b>välittömästi</b> taka-alalle heittämällä
<code>&amp;</code>-merkin komentorivin loppuun:
</p>

<pre class="example">
$ xcalc &amp;
</pre>

<p>
panisi esimerkiksi graafisen laskinohjelman taustalle pyörimään. Tässä
tapauksessa se kuitenkin olisi etualalla, koska ikkunointi pelaa.
</p>
</div>
</div>
<div class="outline-4" id="outline-container-sec-1-12-2">
<h4 id="sec-1-12-2">Jobs</h4>
<div id="text-1-12-2" class="outline-text-4">
<p>
Sinulla voi olla useita ohjelmia samanaikaisesti nukkumassa. Voit
käyttää vain yhtä kerrallaan, koska terminaalissa ei tunneta usean
ikkunan käsitettä. Loput (tai kaikki) ovat unitilassa. Listauksen
ohjelmista näet komentamalla <code>jobs</code>:
</p>

<pre class="example">
# Tämä on zsh:ssä näkyvä listaus
$ jobs
[1]  - suspended  vi fo.vim
[2]  + suspended  sc matikat.sc

# tässä on bashin antama listaus
$ jobs
[1]-  Stopped                 vi fo.vim
[2]+  Stopped                 sc matikat.sc
</pre>

<p>
Työt ovat numeroituja, joten jos haluat palata <code>sc</code>-ohjelman
(taulukkolaskenta) pariin, komento olisi <code>fg %2</code>. Sille annetaan
prosenttimerkki työtunnuksen mukaisesti. Kiltti shelli (kuten kustomoitu
<code>zsh</code>) voi palauttaa töitä nimenkin mukaan:
</p>

<pre class="example">
# ainakin zsh osaa, bashista en tiedä
$ fg %vi
... palauttaa vi-alkuisen prosessin
</pre>

<p>
Vastaavalla tavalla voit heittää jotain tausta-ajoon. Ja aina voit palata
komentoriville pysäyttämällä suorituksen jälleen <code>&lt;C-z&gt;</code>:llä. Hieman kankeata
ehkä, mutta systeemillä on rajansa.
</p>
</div>
</div>
<div class="outline-4" id="outline-container-sec-1-12-3">
<h4 id="sec-1-12-3"><code>ps</code></h4>
<div id="text-1-12-3" class="outline-text-4">
<p>
Toisenlainen näkemys on Unixien perintökalu <code>ps</code> (<b>processes</b>) ja se toimittaa
windowsien Task Managerin virkaa, mutta vain raportointimuodossa. Jos annat
pelkän komennon <code>ps</code>, se listaa sinulle kyseisestä komentorivistä käynnistetyt
prosessit ja joitain tietoja niistä:
</p>

<pre class="example">
$ ps
  PID TTY          TIME CMD
23620 pts/6    00:00:00 zsh
30823 pts/6    00:00:00 ps
</pre>

<p>
Tässä listauksessa näemme vain shellin yksinään, sekä tämän <code>ps</code>-ohjelman,
jonka on luonnollisesti oltava ajossa, jotta se voisi tehdä mitään.
</p>

<p>
Tämä ohjelma pystyy tekemään varsin kattaviakin listauksia, mutta tämän oppaan
kannalta pelkkä <code>ps</code> ja kenties komento <code>ps u</code> ovat mielekkäimmät. Listataan
erilaisia listauksia niistä prosesseista, jotka ovat sinun ajossasi. Graafisia
ohjelmia ja demoneita sinun nimiisi käynnistettynä lisää <code>x</code> mausteeksi. Jos
systeemin oikeudet riittävät, <code>ps aux</code> antaa kokonaisen listan kaikesta, mitä
tietokone jauhaa. Näisä tiedoista tarvitsemme oikeastaan vain ensimmäistä, eli
PID-numeroa (<b>process id</b>) seuraavaa kappaletta varten. Ehkäpä pieni <code>ps fu</code>
valaisee myös prosessien omistussuhteita:
</p>

<pre class="example">
$ ps fu
USER       PID %CPU %MEM  TTY   TIME COMMAND
progo    23620  0.0  0.0  pts/6 0:00 zsh
progo    31204  0.0  0.0  pts/6 0:00  \_ ps uf
progo    23607  0.0  0.1  pts/5 0:01 zsh
progo    29547  0.1  1.0  pts/5 0:03  \_ vim fieldtest.rst
progo    15667  0.0  0.0  pts/7 0:00 zsh
progo     4425  0.0  0.7  pts/4 4:23 irssi
progo     3581  0.0  0.0  pts/3 0:00 zsh
progo     5606  0.0  0.0  pts/3 0:00  \_ tail -n 100 -f /var/log/messages
progo     5607  0.0  0.1  pts/3 0:18  \_ /usr/bin/csi -script koodi/messages
progo     3565  0.0  0.1  pts/2 0:05 zsh
progo     3536  0.0  0.0  pts/0 0:00 zsh
progo      319  0.0  0.0  pts/0 0:00  \_ screen -rd i
</pre>

<p>
Katsoin parhaaksi hieman tiivistää esitystä, jotta se mahtuisi nätisti tähän.
Pientä visuaalisuutta antava flagi <code>f</code> piirtää puumuotoon sen, mitä on
mistäkin ohjelmasta käynnistetty. Ja kun jotain avaa shellin kautta, shelli on
sen prosessin eräänlainen äiti. Flagin <code>u</code> avulla saamme jonkinlaisen listan
komentoriviltä käynnistettyjä ohjelmia. Graafiset ohjelmat eivät näy tässä
listassa; sitä varten pitää heittää vielä <code>x</code>-flagi mukaan.
</p>

<p>
Etätyöskentelyssä tuskin näet näin montaa <code>zsh</code>-istuntoa auki, mutta
työpöydällä ikkunoita on herkästi liikaakin auki, ja jokaisessa on oltava
shell-istunto päällä.
</p>
</div>
</div>
<div class="outline-4" id="outline-container-sec-1-12-4">
<h4 id="sec-1-12-4">Kill</h4>
<div id="text-1-12-4" class="outline-text-4">
<p>
Joskus prosessi voi kenkkuilla, ja sitten se on lopetettava. Unixeissa
puhutaan tappamisesta, mutta kyseessä ei ole väkivaltainen termi.
Englannissahan puhutaan valojenkin tappamisesta, vaikka halutaan vain
sammuttaa ne.
</p>

<p>
Perinteiseen malliin ohjelma <code>kill</code> vaatii tietääkseen prosessin tunnuksen,
eli PID-numeron. Prosessin tulee olla omasi, tämä ei ole mikään Windows 98.
Edelläolevasta listauksesta voisin poimia vaikkapa irssin PID-numeron 4425.
Sen sulkeminen etänä kävisi näin:
</p>

<pre class="example">
$ kill 4425
</pre>

<p>
Ja sinne meni. Numeroiden muistaminen on aika hankalaa, joten moderneissa
systeemeissä on usein ohjelma <code>pkill</code>, joka on oikeastaan pieni sekoitelma
<code>ps</code>:ää, <code>grep</code>:iä ja <code>sed</code>:iä. Niiden avulla voit antaa hakusanan, jolla
etsitään sopivia prosesseja tapettavaksi:
</p>

<pre class="example">
$ pkill irssi
</pre>

<p>
Toinen vaihtoehto <code>pkill</code>:lle on <code>killall</code>, joka tekee suunnilleen saman. Kill
ei oikeastaan tapa mitään itse, vaan lähettää signaalin eteenpäin, ja kerneli
tekee likaisen työn. Tämä signaali voi olla jotain aivan muuta kuin
lopettamista, mutta erikoisemmat käytöt jätetään itseopiskeluksi (<code>man kill</code>).
</p>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-sec-1-13">
<h3 id="sec-1-13">Screen</h3>
<div id="text-1-13" class="outline-text-3">
<p>
Aiemmin esitettyyn työnohjaukseen (<code>jobs</code>, <code>fg</code>, <code>bg</code>) verrattuna nyt
esiteltävä <b>GNU Screen</b> -ohjelma on kultaa kaikilla tasoilla. Ohjelman
alkuperäinen idea on tarjota pysyviä prosesseja, jotka pyörisivät taustalla
vaikka käyttäjä kirjautuisi ulos välissä.  Palatessaan etätyöhönsä käyttäjä
voi sitten palauttaa aiemman istunnon näkösälle ja kaikki ohjelmat ovat siellä
koskemattomina.
</p>

<p>
Vastaavanlainen ohjelma on <code>tmux</code>, johon on lisätty paljon modernimpia
lähestymistapoja. Sitä en käsittele tässä oppaassa kuitenkaan — ehkäpä joku
vieraileva luennoitsija voisi raapustaa aiheesta?
</p>

<p>
Screenin käyttö on helppoa:
</p>

<ul class="org-ul">
<li>Ensin käynnistetään istunto (<i>sessio</i>) screenin sisälle esimerkiksi
komentamalla pelkästään <code>screen</code>.
</li>
<li>Olemme nyt screenin sisällä, ja sinne on avautunut uusi shell-istunto.
Voimme kirjoitella ja tehdä kuten tavallisessa shellissäkin nyt.
</li>
<li>Kun meille riittää, voidaan shell ja ohjelmat jättää auki screenin sisään.
Irtaudumme screen-istunnosta näppäinyhdistelmällä <code>C-a d</code>. Jos et tähän
hätään muista, mitä tuo tarkoittaa, niin teemme näppäinpainallukset
peräkkäin. Ensin Ctrl-aata ja sitten deetä.
</li>
<li>Nyt olemme palautuneet alkuperäiseen shelliin, josta voimme kirjautua ulos
tai tehdä mitä hyvänsä.
</li>
<li>Pääsemme takaisin samaan screen-istuntoon "kytkeytymällä" siihen.
Komennetaan <code>screen -rd</code>.
</li>
<li>Ja olemme taas screenin sisällä. Kaikki on siinä tilassa kuten jätimme ennen
edellistä irtautumista.
</li>
</ul>

<p>
Ja tätä voidaan toistaa päivästä toiseen. Näin shell-käyttäjät hyödyntävät
screenin ominaisuuksia irssin kanssa, jotta heidän irc-sessionsa eivät
katkeile heidän logattua untenmaille.
</p>

<p>
Screen-istunto lopetetaan simppelisti lopettamalla kaikki sovellukset sen
sisältä.
</p>

<p>
Tässä oli perusmalli siitä, mitä useimmat ovat tulleet hakemaan screeniltä.
</p>
</div>

<div class="outline-4" id="outline-container-sec-1-13-1">
<h4 id="sec-1-13-1">Screen moniajaa</h4>
<div id="text-1-13-1" class="outline-text-4">
<p>
Yhdessä screen-istunnossa ei tarvitse tyytyä yhteen ruutuun kuten paljaaltaan
ajettaessa. Istunto voi sisältää vaikka miten paljon prosesseja, joista
jokainen saa oman <b>ikkunansa</b>.  Näistä ikkunoista et kyllä oletuksena näe kuin
yhden kerrallaan (kunnes seuraavassa luvussa).
</p>

<p>
Oletetaan, että olemme avanneet puhtaan screen-istunnon:
</p>

<pre class="example">
$ screen
$           # &lt;-- tämä on screenin sisällä avattu sessio
</pre>

<p>
Voimme asettaa tänne ajamaan jotain ohjelmia ihan tavalliseen malliin. Nyt
screenin ansiosta meidän ei tarvitse keskeyttää mitään ohjelmia <code>C-z</code>:lla vaan
voimme luoda rinnakkaisen shell-session.  Tähän on komento <code>C-a c</code>. Kun
painat kyseisen kombinaation sisään, ruudulle lävähtää tuorean näköinen
shell-istunto. Vanha ei ole kadonnut mihinkään, vaan se on toisessa ikkunassa.
Nämä ikkunat eivät tarkoita mitään graafisia ruutuja, kuten tavallisesti, vaan
sillä tarkoitetaan vain yhtä näkymää yhteen prosessiin.
</p>

<p>
Tässä uudessa ruudussa voit nyt ajella jotain toista ohjelmaa.
Ikkunoiden välillä on helppoa hyppiä:
</p>

<dl class="org-dl">
<dt> <code>C-a &lt;Space&gt;</code> </dt><dd>seuraava ikkuna
</dd>
<dt> <code>C-a n</code> </dt><dd>seuraava ikkuna
</dd>
<dt> <code>C-a p</code> </dt><dd>edellinen ikkuna
</dd>
</dl>

<p>
Ikkunat luonnollisesti pyörivät silmukassa, eli kun ikkunoita on
vähän, <code>C-a &lt;Space&gt;</code> on luonnollinen tapa kelata oikea akkuna eteensä.
Kokeilehan ihmeessä! Luo parit sessiot ja kirjoita kuhunkin jotain
tunnistettavaa tekstiä.
</p>

<p>
Ikkunan saat suljettua taas sulkemalla siitä kaikki sovellukset. Eli
monesti se shell yksinään.
</p>
</div>
</div>
<div class="outline-4" id="outline-container-sec-1-13-2">
<h4 id="sec-1-13-2">Screen ikkunoitsijana</h4>
<div id="text-1-13-2" class="outline-text-4">
<p>
Oikeasti mielenkiintoinen osuus  alkaa siitä kysymyksestä, että miten voimme
valjastaa screenin jakamaan se meille annettu yksi terminaali-ikkuna useaan
osaruutuun, joissa voi pyöriä samanaikaisesti eri sovellukset.  Screen kun
nimittäin osaa tehdä sellaistakin.
</p>

<p>
Käytetään esiteltyjä screen-ikkunoita apunamme. Kun kussakin ikkunassa on omat
sovelluksensa ajamassa, niitä voidaan laittaa näytille <i>jakamalla</i>
screen-ruutu kahteen tai useampaan palaseen. Kussakin palasessa näkyy tasan
yksi ikkuna (tai ei ikkunaa; silloin se on tyhjää täynnä).
</p>

<p>
Jakaminen tapahtuu komennolla <code>C-a S</code> (<i>split</i>). Uudet ruudut ovat oletuksena
tyhjiä. Niihin voit joko vaihtaa jonkun olemassaolevan ikkunan tai sitten
luoda uuden ikkunan edelläesitellyin komennoin.
</p>

<p>
Ruutujen välillä tulee kyetä vaihtelemaan. Siihen on komento <code>C-a Tab</code>. Pientä
hupia saa aikaan jakamalla ruutua palasiin ja asettamalla palasiin sama ikkuna
näkyville. Tekstisi näyttää monistuvan useaan ruutuun, vaikka kyseessä onkin
sama ikkuna.
</p>

<p>
Ruutuja ei voi luoda vieretysten, vain päälletysten. Tutki <code>tmux</code>-ohjelmaa,
jos vierekkäinen näkyvyys on tärkeätä.
</p>

<p>
Ruutujen kokoa voi muuttaa <code>C-a +</code> ja <code>C-a -</code> -näppäimin.  Ruutu suljetaan
näppäinkomennolla <code>C-a X</code>. Myös screenistä irtautuminen sulkee ylimääräiset
ruudut. Ikkunat toki säilyvät, mutta joudut jakamaan ruutua aina kun screenin
panet taustalle.
</p>
</div>
</div>
<div class="outline-4" id="outline-container-sec-1-13-3">
<h4 id="sec-1-13-3">Muuta kivaa screenissä</h4>
<div id="text-1-13-3" class="outline-text-4">
<p>
Ja hauska ei ole vielä läheskään lopussa! Screen sisältää aivan valtavat
määrät apukeinoja kaikenlaiseen. Voit jopa havaita, että ilman screeniä ei
terminaalityöskentelystä tulisi mitään. Ainakin silloin, jos olet oikeasti
konsoliympäristössä, eli ei graafista ympäristöä ympärilläsi.
</p>

<p>
Screen-istunnon voit lukita siten, että kukaan ei pääse sitä tirkistelemään.
Joudut antamaan salasanasi jotta pääset takaisin istuntoon käsiksi. Tämä
komento on <code>C-a x</code>.
</p>

<p>
Voit myös selata ruudun tekstejä samalla tavalla kuin jos käytettävissäsi
olisi vierityspalkki. Screen käyttää sellaisia konsteja ruudun piirtämiseksi,
että luultavasti graafisen terminaaliohjelmasi omat vierityspalkit eivät toimi
kivasti! Pelko pois, sillä screenin tarjoama ikkunanselaus on erinomaista
luokkaa. Siihen pääset komentamalla <code>C-a &lt;Esc&gt;</code>. Nyt voit nuolinäppäimin
selailla ylöspäin kaikkea näkynyttä. (Se ei tietenkään toimi
kokoruutusovelluksien, kuten irssin tai vimin kanssa hyvin. Se ei ole iso
ongelma, koska valtaosa kokoruutusovelluksista toteuttaa omat keinot selata
backlogia.)
</p>

<p>
Mikä hienointa, tämä selausmoodi toteuttaa luultavasti <b>kaikki</b>
<code>less</code>-ohjelman työkalut. Voit jopa hakea hakusanoilla. Tätä ei totisesti
pelkällä vierityspalkilla voi toteuttaa. Vilkaisepa <a href="#less">1.5.2.6</a>-kappaleesta vähän
kertausta kaikkiin mahdollisuuksiisi. Tämän lisäksi tämä selausmoodi toteuttaa
useita <code>vi</code>-komentojakin kaupanpäälle. Pääset pois selausmoodista painamalla
Esciä. Nyt voit jatkaa ikkunan käyttöä tavalliseen malliin.
</p>

<p>
Jotta mahdollisuudet todella pääsevät oikeuksiinsa, screenissä voit myös
suorittaa kopiointia ja liittämistä kaikesta ruudullanäkyvästä.
Hiirivetoisissa systeemeissä ehkä selviää nopeammin hiiren avulla, mutta
joskus ei kursoria ole käytettävissä. Tämä malli on myös nopeampi osaavissa
käsissä.
</p>

<p>
Kopiointia voit tehdä siirtymällä mainittuun selausmoodiin ja navigoimalla
haluttuun alkamiskohtaan. Painat välilyöntiä aloittaaksei maalauksen. Nyt voit
liikkua nuolinäppäimillä tai vaikkapa <code>vi</code>-näppäimin miten haluat. Valittu
maalaus kopioidaan painamalla väliä uudestaan.
</p>

<p>
Nyt tämän kopion voi liittää mihin tahansa screen-ikkunaan sessiosi sisällä.
Näppäinkomento on <code>C-a ]</code>. Tietenkään et voi liittää minne tahansa. Kun liität
screenin kautta ohjelmaan, se näkyy ohjelmalle kuin olisit itse kirjoittanut
tekstin siinä muodossa kun se liitetään. Tämä on valtava apu esimerkiksi kun
yrität setvitellä, missä meni vikaan ja graafinen systeemi on
käyttämättömissä.
</p>
</div>
</div>
<div class="outline-4" id="outline-container-sec-1-13-4">
<h4 id="sec-1-13-4">Yhteenveto</h4>
<div id="text-1-13-4" class="outline-text-4">
<p>
No niin. Screen on iso ja monipuolinen sovellus, josta olemme vain raapaisseet
perusteet ja vain vähän pintaa syvemmältä. Parhaiten näet, mitä kaikkea tämä
ohjelma sisältää on tutkia sen manpageja (<code>man screen</code>) ja selailemalla
rauhassa listoja. 
</p>

<p>
Tehdään tänne pieni yhteenvetotaulukko esitellyistä komennoista, ja näillä
pääset alkuun.
</p>

<table frame="hsides" rules="groups" cellpadding="6" cellspacing="0" border="2">


<colgroup>
<col class="left"></col>

<col class="left"></col>
</colgroup>
<thead>
<tr>
<th class="left" scope="col">Näppäin</th>
<th class="left" scope="col">Komento</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>C-a d</code></td>
<td class="left">Irtaudu istunnosta (jätä taustalle)</td>
</tr>

<tr>
<td class="left"><code>C-a c</code></td>
<td class="left">Uusi ikkuna</td>
</tr>

<tr>
<td class="left"><code>C-a SPC</code></td>
<td class="left">Seuraava ikkuna</td>
</tr>

<tr>
<td class="left"><code>C-a n</code></td>
<td class="left">Seuraava ikkuna</td>
</tr>

<tr>
<td class="left"><code>C-a p</code></td>
<td class="left">Edellinen ikkuna</td>
</tr>

<tr>
<td class="left"><code>C-a S</code></td>
<td class="left">Jaa ruutu kahteen</td>
</tr>

<tr>
<td class="left"><code>C-a &lt;Tab&gt;</code></td>
<td class="left">Vaihda palasten välillä</td>
</tr>

<tr>
<td class="left"><code>C-a +</code></td>
<td class="left">Kasvata ruutua</td>
</tr>

<tr>
<td class="left"><code>C-a -</code></td>
<td class="left">Kutista ruutua</td>
</tr>

<tr>
<td class="left"><code>C-a X</code></td>
<td class="left">Sulje ruudunpalanen</td>
</tr>

<tr>
<td class="left"><code>C-a x</code></td>
<td class="left">Lukitse screen-istuntosi</td>
</tr>

<tr>
<td class="left"><code>C-a &lt;Esc&gt;</code></td>
<td class="left">Selaa ikkunan sisältöä</td>
</tr>

<tr>
<td class="left"><code>&lt;Space&gt;</code></td>
<td class="left">Aloita/lopeta kopiointi (selaustilassa)</td>
</tr>

<tr>
<td class="left"><code>&lt;Esc&gt;</code></td>
<td class="left">Lopeta selaustila (selaustilassa)</td>
</tr>

<tr>
<td class="left"><code>C-a ]</code></td>
<td class="left">Liitä kopiointi ikkunaan</td>
</tr>

<tr>
<td class="left"><code>C-a ?</code></td>
<td class="left">Screenin oma näppäinlistaus</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-sec-1-14">
<h3 id="sec-1-14">Editorit</h3>
<div id="text-1-14" class="outline-text-3">
<p>
Editorit – eli miten muokkailla ja käsitellä puhdasta tekstiä komentorivien
tekstigraafisessa maailmassa. Käyttäjällä on komentorivillään täysi vapaus
käyttää haluamaansa editoria tiedostojen käsittelyyn, kuten graafisessa
maailmassa voit valita ohjelmasi vapaasti. On myös tapauksia, jossa jokin
toinen ohjelma haluaa käyttäjän käsittelevän tiedostoa. Hyvinkäyttäytyvä
ohjelma siten katsoo eräästä paikasta sen ohjelman, jota käyttäjä erityisesti
haluaa käyttää.
</p>

<p>
Tämä paikka on ympäristömuuttuja <code>$EDITOR</code>. Jos tiedät jonkun komentoriviltä
ajettavan editorin, niin voit asettaa sen tämänlaisella komennolla
<code>bash</code>-sukuisissa shelleissä:
</p>

<pre class="example">
export EDITOR=nano
</pre>

<p>
Tässä asetimme editoriksi aloittelijaystävällisen <code>nano</code>-editorin. Jos <code>nano</code>
ei ole asennettuna systeemiin, on yleensä vanhempi <code>pico</code> tarjolla, ja toimii
samaan tapaan. Esimerkkejä yleisistä editoreista ovat <b>pico</b>, <b>nano</b>, <b>vi</b> ja
<b>emacs</b>.  Käsittelemme joitain noista jonkin verran nyt seuraavaksi, jotta
tiedät, missä mennään.
</p>

<p>
Ylläolevan <code>export</code>-rivin voi laittaa shellin käynnistystiedostoon, jotta
asetuksesi säilyy päällä jatkossakin, mutta katsellaan sitä editorikatsauksen
jälkeen. Kun osaamme editoida niitä käynnistystiedostoja.
</p>
</div>
</div>
<div class="outline-3" id="outline-container-sec-1-15">
<h3 id="sec-1-15">Nano</h3>
<div id="text-1-15" class="outline-text-3">
<dl class="org-dl">
<dt> Matias </dt><dd>Olemme puhuneet paljon editoreista, mutta ette
taida vielä osata ainuttakaan, joka toimii hyvin
terminaalissa.
</dd>
<dt> Hemmo-Joachim </dt><dd>No <code>nano</code> on kyllä mulle tuttu.
</dd>
<dt> Matias </dt><dd>Ai on? Voit käydä sen. Minä ajattelin <code>vi</code>:llä
aloitella, mutta ehkä on parempi ottaa helpommin.
</dd>
<dt> Ville </dt><dd>Mutta miksi ei voida käyttää vaikka Katea? Olisi
sentään jotain järkeä tuossa editoinnissa.
</dd>
<dt> Matias </dt><dd>Katellako meinasit editoida ssh-yhteyden yli?
Onnistuu se kai jotenkin, mutta on hyvä osata
käsitellä tiedostoja ihan paikanpäältä.

<p>
Hemmo voinee nyt ottaa ohjakset, kun en ole noita kahta
käytellyt aikoihin. Liekö ikinä, kun tarkemmin miettii.
</p>
</dd>
<dt> Hemmo-Joachim </dt><dd>Mitä kahta?
</dd>
<dt> Matias </dt><dd><code>nano</code> pohjautuu vanhempaan <code>pico</code>-editoriin. Jos
<code>nano</code> ei ole asennettuna, niin <code>pico</code>:n pitäisi
ainakin olla.

<p>
Ja kun nanoa osaa käyttää, niin picon alkeet ovat täsmälleen
samat.
</p>
</dd>
<dt> Hemmo-Joachim </dt><dd>No ok. Nanon käyttäminen on helppoa kyllä. Jos sen
käynnistää sellaisenaan, niin se tarjoaa tyhjää
tiedostoa, johon voi kirjoitella. Kuin Muistio.
</dd>
</dl>


<div class="figure">
<p><img alt="nano-empty.png" src="../pics/nano-empty.png" />
</p>
</div>

<dl class="org-dl">
<dt> Matias </dt><dd>Onpas ruma.
</dd>
<dt> Ville </dt><dd>No elä.
</dd>
<dt> Hemmo-Joachim </dt><dd>No, nyt se siinä kuitenkin sitten seisoo. Ja tosta
alhaalta on helppo katsella ne tärkeimmät
pikanäppäimet, ei ole tarvetta tehdä listausta.
Noita sitten luetaan niin, että <code>^X</code> tarkoittaa
<code>Ctrl-X</code>:ää. Ja <code>M-F</code> tarkoittaa <code>Alt-f</code>:ää.
</dd>
<dt> Ville </dt><dd>Mistä se <code>M</code> siihen sitten tulee?
</dd>
<dt> Matias </dt><dd>M niin kuin Meta. Metanäppäin oli vähän
vaihtelevampi käsite vanhoissa tietokoneissa.
Nykyisin se on toki lähes satavarmasti Alt. Jos
huomaatte joskus, että <code>Alt-f</code> ei toimikaan (jotkut
terminaaliklientit ja Windowsin SSH-ohjelmat voivat
tehdä tätä) niin vaihtoehto on painaa ensin Esciä
ja sitten loput näppäinyhdistelmästä.

<p>
Nämä kaksi näppäilyä tuottavat siis saman <code>M-F</code> -yhdistelmän:
</p>

<ul class="org-ul">
<li><code>ESC f</code>
</li>
<li><code>Alt-f</code>
</li>
</ul>
</dd>
<dt> Hemmo-Joachim </dt><dd>No johan on. Joskus ei ole toiminut toi altti
esimerkiksi irssissä niin en ole osannut vaihdella
kanavia.
</dd>
<dt> Ville </dt><dd>No sen mä tiesinkin, että irssissä voi käyttää
molempia muotoja. En vaan arvannut, että se on
yleinen toiminta.
</dd>
<dt> Matias </dt><dd>Näin se on. Jatkammeko nanon parissa?
</dd>
<dt> Hemmo-Joachim </dt><dd>Joo tota. Tiedoston avaaminen nanoon on helpoin
tehdä ton käynnistyksen yhteydessä:

<pre class="example">
nano [File]
</pre>

<p>
Ja se näyttää tältä:
</p>
</dd>
</dl>


<div class="figure">
<p><img alt="nano-opened.png" src="../pics/nano-opened.png" />
</p>
</div>

<dl class="org-dl">
<dt> Hemmo-Joachim </dt><dd>Ja nyt siinä voi liikkua ja muokata kuin
Muistiossakin. Hassusti pastetus on nimetty <code>UnCut</code>
– en tiedä, onko se sitten vain vanhempi termi
sille.

<p>
Mutta muuten. <code>^W</code> on näppärä tapa hakea
hakusanalla – ja kirjainkoolla ei ole merkitystä.
Haun voi toistaa näppäinyhdistelmällä <code>M-W</code>. Eipä
tossa ole muuta ihmeellistä.
</p>

<p>
Niin, savetus onnistuu <code>^O</code>:lla. Se kysyy kyllä tiedostonimeä,
mutta se vanha nimi on siinä oletuksena, joten voit painaa
enteriä niin se tallentaa päälle.
</p>

<p>
Ja pois pääsee <code>^X</code>:stä, kuten alapalkissa lukeekin.
</p>
</dd>
<dt> Matias </dt><dd>Ja ehkä tärkein asia unohtui…
</dd>
<dt> Hemmo-Joachim </dt><dd>Mikä?
</dd>
<dt> Matias </dt><dd>No olisiko ohje. Se näkyy olevan kuvien perusteella
<code>^G</code>. Kannattaa aina kattella ensin ohjeista, jos
ei tiedä, mitä on etsimässä. Tutkailin tuota
ohjetta ja siinä on noi näppäimet ja toiminnot
selkeästi esillä.
</dd>
<dt> Hemmo-Joachim </dt><dd>Niin on joo.
</dd>
<dt> Matias </dt><dd>Ainut vain, että hakutoiminto ei näytä toimivan
ohjeikkunassa. Aika kehnoa suunnittelua.
</dd>
<dt> Ville </dt><dd>Mutta hei – avasin jonkun oman jutun, ja ne rivit
menee näytön ulkopuolelle. Miten tässä voi panna
rivityksen päälle?
</dd>
<dt> Matias </dt><dd>Näyttäisi olevan ainakin optio <code>-$</code>, joka tekee
sen. Voit toki aktivoida sen vasta nanon sisällä,
näppäinkomennolla <code>M-$</code>, joka on tietty vähän
hankala euronäppiksille.

<p>
Mutta nano rivittää rumalla tavalla. Se voi
kuulostaa pöljältä, mutta useimmat Unix-ohjelmat
pitävät kapeista tiedostoista.
</p>
</dd>
</dl>

<p>
Riittäisiköhän se nanosta (ja picosta)?
</p>
</div>
</div>
<div class="outline-3" id="outline-container-sec-1-16">
<h3 id="sec-1-16">Vi</h3>
<div id="text-1-16" class="outline-text-3">
<dl class="org-dl">
<dt> Hemmo-Joachim </dt><dd>Hei Masa, miten tästä pääsee ulos?
</dd>
<dt> Matias </dt><dd>Mitäs olit tekemässä?
</dd>
<dt> Hemmo-Joachim </dt><dd>No yhdessä ohjeessa puhuttiin tiedoston
editoimisesta <code>vi</code>-ohjelmalla.
</dd>
<dt> Matias </dt><dd>Ah, vanha tuttu <code>vi</code>. Voidaankin käydä sen alkeet
läpi. Ja nyt puhun todella vain alkeista, sillä
editoreja on muitakin. Vi on kuitenkin niin
yleinen, että ainakin on hyvä opetella pärjäämään
sen kanssa.
</dd>
</dl>

<p>
Vi on 70-luvun lopuilla rakennettu interaktiivinen kokoruudun editori. Sitä
ennen tehtävät tehtiin rutkasti hankalammin ns. rivieditorien voimin.
Ensimmäinen Unix kirjoitettiin rivieditorin voimin. Myös Vi on vanha ja kankea
tapa tehdä tekstin editoimista nykypäivänä, mutta auttaa tuntea sen perusteet.
Ja jos idea jostain syystä kuulostaakin hyvältä, Vi:n modernisointi Vim on
nykyaikainen ja monipuolinen editori kaikenlaisiin tekstitehtäviin.
</p>

<p>
<code>Vi</code> on <code>ed</code>:in ohella niitä klassikko-ohjelmia, jotka kaappaavat muuten hyvin
yleisen keskeytyskomennon <code>&lt;C-c&gt;</code> omiin tarkoituksiinsa, joten sitä painamalla
ei pääsekään ulos editorista. Senkin takia on nyt hyvä kertoa minimaalinen
katsaus tähän ohjelmaan.
</p>
</div>

<div class="outline-4" id="outline-container-sec-1-16-1">
<h4 id="sec-1-16-1">Keskeiset komennot</h4>
<div id="text-1-16-1" class="outline-text-4">
<dl class="org-dl">
<dt> Matias </dt><dd>Annahan kun minä listaan teille joitain
peruskomentoja vi:stä.
</dd>
</dl>

<table frame="hsides" rules="groups" cellpadding="6" cellspacing="0" border="2">


<colgroup>
<col class="left"></col>

<col class="left"></col>

<col class="left"></col>

<col class="left"></col>
</colgroup>
<tbody>
<tr>
<td class="left"><code>:q!</code></td>
<td class="left"><b>Sulkee tallentamatta</b></td>
<td class="left"><code>:w</code></td>
<td class="left">Tallentaa tiedoston</td>
</tr>

<tr>
<td class="left"><code>:wq</code></td>
<td class="left">Tallentaa ja sulkee</td>
<td class="left"><code>yy</code></td>
<td class="left">Kopioi rivi</td>
</tr>

<tr>
<td class="left"><code>i</code></td>
<td class="left">Hyppää insert-modeen</td>
<td class="left"><code>p</code></td>
<td class="left">Liitä rivi alle</td>
</tr>

<tr>
<td class="left"><code>&lt;ESC&gt;</code></td>
<td class="left">Poistu insert-modesta</td>
<td class="left"><code>P</code></td>
<td class="left">Liitä rivi ylle</td>
</tr>

<tr>
<td class="left"><code>k</code></td>
<td class="left">Ylös</td>
<td class="left"><code>dd</code></td>
<td class="left">Leikkaa rivi</td>
</tr>

<tr>
<td class="left"><code>j</code></td>
<td class="left">Alas</td>
<td class="left"> </td>
<td class="left"> </td>
</tr>

<tr>
<td class="left"><code>h</code></td>
<td class="left">Vasemmalle</td>
<td class="left"><code>l</code></td>
<td class="left">Oikealle</td>
</tr>
</tbody>
</table>

<dl class="org-dl">
<dt> Ville </dt><dd>WTF?!
</dd>
<dt> Matias </dt><dd>Tiedän, että se näyttää vähän pahalta.
</dd>
<dt> Hemmo-Joachim </dt><dd>Hyvä että panit tärkeimmän näkyville ensimmäisenä!
Miten ketään voi käyttää tuommosta – ja <code>jk</code>
nuolinäppäimien sijasta.
</dd>
<dt> Matias </dt><dd>Tämä editori saa voimansa siitä, että
liikkumakomentoja on valtavasti erilaisia, ja
kaikki helposti saatavilla näppituntumalla. Se on
saavutettu tekemällä vi:stä modaalinen.
</dd>
</dl>

<p>
Modaalisuus tarkoittaa tässä tapauksessa sitä, että editorin eri
tiloissa (moodeissa) näppäinkomentojen merkitys vaihtelee. Vi:ssä on
useita eri moodeja, mutta kaksi tärkeintä riittää mainita
oleellisuuden vuoksi:
</p>

<dl class="org-dl">
<dt> normaalitila (normal mode) </dt><dd>Tämä on tila, jossa liikutaan
tiedostossa. Tästä tilasta pääsee ulos vi:stä, joka lienee
tärkeintä tietää tässä vaiheessa.
</dd>
<dt> lisäystila (insert mode) </dt><dd>Tähän tullaan normaalitilasta komennolla
<code>i</code>. Nyt aakkoset toimivat tavalliseen tekstinsyöttötapaan. Tästä
tilasta pitää tulla erikseen ulos kaikkea liikkumista varten. Se
tapahtuu yleensä Esciä painamalla, mutta ehkä helpompaa on
käyttää <code>&lt;C-c&gt;</code>:tä (Ctrl-C)
</dd>
</dl>

<p>
Tilakaavion muodossa näin:
</p>


<div class="figure">
<p><img alt="vi-modes.png" src="../pics/vi-modes.png" />
</p>
</div>

<dl class="org-dl">
<dt> Hemmo-Joachim </dt><dd>Mä taidan jatkaa ton <code>nano</code>:n kanssa. Ja mikä
ihmeen juttu toi <code>hjkl</code> on – eikö vanhoissa
koneissa ollut nuolinäppäimiä?
</dd>
<dt> Matias </dt><dd>Kyllä niissä oli, mutta eräät terminaalit
lähettivät niistä aakkoskoodeja, juuri nuo
pahamaineiset näppäimet.

<p>
Mutta toisaalta myöhemmin havaittiin, että <code>hjkl</code>
toimii kivasti ihan yksinäänkin, vaikka
näppäimistössä olisikin nuolta tarjolla.
</p>

<p>
Teidän kannattaa vain toivoa, että niissä
Unix-ympäristöissä, joissa liikutte, tulee
nuolinäppäimet luetuksi oikein. Jos ei, niin on
parempi alkaa totutella noihin <code>hjkl</code>:ään.
</p>
</dd>
<dt> Ville </dt><dd>Taitaa toi aiemmin käsitelty <code>nano</code> olla ihan
sopiva meikälle.
</dd>
</dl>
</div>
</div>
<div class="outline-4" id="outline-container-sec-1-16-2">
<h4 id="sec-1-16-2">Vim</h4>
<div id="text-1-16-2" class="outline-text-4">
<p>
Vi oli aikoinaan suljettua koodia, ja sitä ei saatu niin monelle
tietokoneelle kuin olisi ollut kysyntää. Siitä tehtiinkin paljon
klooneja, joista yksi on nykypäivänäkin kovaa kamaa: 90-luvun alussa
syntynyt <b>Vim</b>. Vim perii kaiken, mitä alkuperäinen ja kankea <code>vi</code>
on, ja lisää <i>sairaasti</i> lisää toiminnallisuutta vanhan päälle.
</p>

<p>
Jos teidän käy tuuri, on systeemissä asennettu jo Vim tavallisen vi:n
sijaan. Voitte saada syntaksiväritystä ja todennäköisemmin toimivaa
nuolinäppäintä. Sekä sellaista herkkua kuten online-ohjeita (kokeile
komentoa <code>:help</code> normaalitilassa).
</p>
</div>
</div>
<div class="outline-4" id="outline-container-sec-1-16-3">
<h4 id="sec-1-16-3">Jatkoa varten</h4>
<div id="text-1-16-3" class="outline-text-4">
<p>
Yksi opas on erityisen hyvää luettavaa, jos Vi:n käytön syvempi
opettelu kiinnostaa: <a href="http://oreilly.com/catalog/9780596529833">Learning the vi and Vim Editors</a> (Robbins, Hannah,
Lamb). Hyvää luettavaa, jos mielesi tekee hakkeriksi, vaikka olisitkin
valinnut Emacs-tien. Kirjassa käydään <code>ex</code>-rivieditorin perusteet
sellaisenaan. Siitä on hyötyä skriptauksessa.
</p>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-sec-1-17">
<h3 id="sec-1-17">Kehittyneitä työkaluja</h3>
<div id="text-1-17" class="outline-text-3">
<p>
Tiedostojen kanssa on niin helppoa työskennellä, koska ne ovat aina
samanlaista ihmislukuista massaa. Eräs ohjelmointialan sanonta sopii
tähänkin kontekstiin:
</p>

<p>
On parempi luoda 100 työkalua yhteen tietorakenteeseen kuin tehdä 10
työkalua kymmeneen eri tietorakenteeseen.
</p>

<p>
Tässä tietorakenteena voidaan ajatella olevan puhtaan tekstin.
Käsitelläänpä nyt paria työkalua, jotka liittyvät asiaan jotenkin.
</p>
</div>

<div class="outline-4" id="outline-container-sec-1-17-1">
<h4 id="sec-1-17-1"><code>diff</code></h4>
<div id="text-1-17-1" class="outline-text-4">
<p>
Kahden tiedoston välisiä eroja on joskus tarve ihmetellä. Erityisesti
kun <code>diff</code> (<b>difference</b>) pystyy näpsäkästi tekemään monenlaisia
vertailuja ja ilmaisuasuakin voi muuttaa.
</p>

<p>
Tuttavallisesti puhekielessä vain <b>diffi</b> on näppärä tapa esittää tekemiään
muutoksia tiedostoihin, kun esitysasusta näkee siististi päällepäin kaiken,
mitä on lisätty tai poistettu. Vaikka diffejä ei tarvitsekaan useasti
ohjelmointihommien ulkopuolella, on hyvä tuntea näiden tekemien tulosteiden
erot ja se, miten diff-filettä luetaan.
</p>

<p>
Oletusasetuksissa <code>diff</code> antaa tunnustetusti huonon koosteen. Oletetaan
seuraavat kaksi testitiedostoa kokeilujamme varten:
</p>

<pre class="example">
$ cat a
a
Lammas, vuohi ja susi.
Ei näin? Ei koiran voittanutta?
Onkohan nyt tarpeeksi sisältöä.
$ cat b
b
Lammas, vuohi ja susi.
Ei koiran voittanutta.
Onkohan nyt tarpeeksi sisältöä.
Ei varmaan, mutta ainahan
 sitä voi toivoa.
</pre>

<p>
Vertailu on yleensä järkevää vain, kun valtaosa vertailtavien tiedostojen
sisällöistä on samaa. Näissä on muutamia yhteisiä rivejä, ja oletetaan
vaikkapa tiedostoa <code>a</code> muutetun hieman <code>b</code>:n suuntaan.
</p>

<p>
Nyt näiden kahden vertailu oletusasetuksin antaa tiiviin ja epäselvän
syötteen:
</p>

<pre class="example">
$ diff a b
1c1
&lt; a
---
&gt; b
3c3
&lt; Ei näin? Ei koiran voittanutta?
---
&gt; Ei koiran voittanutta.
4a5,6
&gt; Ei varmaan, mutta ainahan
&gt;  sitä voi toivoa.
</pre>

<p>
Tulosteessa käytetään hakasia ilmaisemaan lisäystä vasemman- tai
oikeanpuoleisen tiedoston suhteen. Se, että kumpi on vasen ja kumpi oikea,
määräytyy komentoriviargumenttien antojärjestyksestä. Diff antaa lisäksi
kryptisiä ohjaussyötteitä tietokonetta varten. Tämä ei ole pelkästään
ihmiselle hankalaa luettavaa, vaan myös tietokoneella on hankaluuksia soveltaa
tätä tekstiä ilman kontekstia (kts. seuraava kappale). Kokeillaan vähän
parempaa tulostusmuotoa, annetaan diffin kertoa kontekstia, eli muutoksia
edeltäviä ja seuraavia rivejä helpottamaan:
</p>

<pre class="example">
$ diff -U 3 a b
--- a   2011-11-21 19:59:19.636191339 +0200
+++ b   2011-11-21 19:59:38.229524808 +0200
@@ -1,4 +1,6 @@
-a
+b
 Lammas, vuohi ja susi.
-Ei näin? Ei koiran voittanutta?
+Ei koiran voittanutta.
 Onkohan nyt tarpeeksi sisältöä.
+Ei varmaan, mutta ainahan
+ sitä voi toivoa.
</pre>

<p>
Tässä syötteessä annetaan ensin selite, eli annettujen tiedostojen strategiset
mitat, ja samalla symboloidaan ensimmäinen tiedosto miinuksella ja
jälkimmäinen tiedosto plussaksi. Kahden at-merkin ympäröimä kontekstirivi
kertoo sen, että missä mennään: <code>-1,4</code> tarkoittaa, että nyt katselemme
tiedoston <code>a</code> rivejä 1-4. Vastaavasti <code>+1,6</code> tarkoittaa tiedoston <code>b</code> rivejä
1-6. Niitä on enemmän merkattu kontekstiin, ja ne näkyvät sitten alla.
Yhteiset rivit ovat ilman miinus- tai plusmerkkiä.
</p>

<p>
Nyt on jo paljon paremmat eväät nähdä, mitä on <b>poistettu</b> ja <b>lisätty</b>
versioiden välillä, kun alkuperäisessä puhutaan vain puhtaista eroista
tiedostojen välillä. Flagi <code>-U</code> eli <b>unified</b> antaa yhtenäisille riveille
sijaa. Se on pitkälti samanlainen kuin <code>-C</code> eli <b>context</b>. Pieniä
näkemyseroja. Lukuarvona annetaan rivien lukumäärä. Samaa asiaa mutta joskus
kannattaa valita selkeämpi versio. Etenkin kun tietokone lukee kontekstin
avulla diff-filejä paljon paremmin. Siitä seuraavaksi!
</p>
</div>
</div>
<div class="outline-4" id="outline-container-sec-1-17-2">
<h4 id="sec-1-17-2"><code>patch</code></h4>
<div id="text-1-17-2" class="outline-text-4">
<p>
Diffin käänteistyökalu on <code>patch</code> eli jos meillä on alkuperäinen
tiedosto ja sitten jokin difffile olemassa, niin voimme suorittaa
käänteisen operaation tiedostoille. Voisimme luoda edellisen esimerkin
tiedostosta <code>a</code> tiedoston <code>b</code>, kun tiedämme diffin sisällön. Näitä
kutsutaankin sitten patch-fileiksi, jos tiedostot on erityisesti luotu
pätsäystä varten.
</p>

<p>
Edellisestä esimerkistä suoraan:
</p>

<pre class="example">
$ diff -U 3 a b &gt; b.patch
$ patch &lt; b.patch
$ diff a b
$
</pre>

<p>
Eli <code>patch</code> muutti diff-fileen mukaan tiedoston <code>a</code> nyt täsmälleen
samaksi kuin tiedosto <code>b</code>. Siksi kolmas diff-komento antoi tyhjää
vastaukseksi: tiedostot ovat samat.
</p>

<p>
Tämä ohjelma, kun se 80-luvulla kehitettiin, mullisti avointen
ohjelmien levityksen kokonaan. Enää ei tarvinnut uutta versiota varten
toimittaa koko ohjelmaa alusta alkaen, vaan selvittiin parilla
kilotavulla. Lisäksi tiedostoa <code>a</code> voi tietyssä määrin muokata tuossa
välissä, ja pätsäys voi silti onnistua sulavasti. Siihen vaikuttaa
kontekstirivien määrä. Esimerkissämme olisi selvitty diffin
oletustulosteillakin, mutta <code>patch</code> epäonnistuu herkästi jos olisin
muokannut a:ta välissä hieman. Esimerkiksi siten, että rivinumerot
eivät enää pitäisikään paikkansa. Kontekstin tarjoaminen auttaa
merkittävästi.
</p>
</div>
</div>
<div class="outline-4" id="outline-container-sec-1-17-3">
<h4 id="sec-1-17-3"><code>make</code></h4>
<div id="text-1-17-3" class="outline-text-4">
<p>
Simppelisti nimetty <code>make</code> (tee) tekee tehtäviä reseptien mukaan.
Monissa hommissa, kuten kakunpaistossa, on kullekin tehtävänosalle
omia esivaatimuksia, joiden on täytyttävä ensin. Koska tietokoneiden
maailmassa tehtävät voivat paisua mielivaltaisen suuriksi, on parasta
jättää kaikenlainen tehtävänjako ja esivaatimuksien selvittely
tietokoneen puuhaksi. Esittelen vain ohjelman perusidean, koska
teknisempi esittely on aika spesifiseksi menevää.
</p>

<p>
Make lukee <code>Makefile</code>-nimistä tiedostoa, jossa sijaitsevat kaikki
reseptit. Nämä reseptit eli osatehtävät on kirjoitettu seuraavaan
muotoon:
</p>

<pre class="example">
kohde: esivaatimukset
    tehtävä
</pre>

<p>
Esimerkiksi taloa rakennettaessa voisi olla seuraavanlaisia askareita
määriteltynä:
</p>

<pre class="example">
sementti:
    sekoita sementtiä

pohja: sementti
    vala perustus

porras: pohja sementti
    vala vain

seinät: pohja
    pystytä seinät

katto: seinät
    rakenna sekin

talo: porras katto
    valmista on
</pre>

<p>
Make selvittelee kaikki eri askareet ja hoitaa rekursiivisesti kaikki
esivaatimukset kuntoon ennen kuin ryhdytään tekemään haluttua
vaihetta. Jos käyttäjä komentaisi <code>make porras</code> eikä pohjaa olisi
vielä valettu, niin Make tekisi pohjan ensin. Ja tarpeen mukaan
sotkisi lisää sementtiä käytettäväksi. Viimeinen vaihe voi usein olla
pelkkä listaus esivaatimuksia eikä mitään varsinaista työtä tarvitse
tehdä. Silloin vain varmistetaan, että Make on tehnyt kaiken
tarvittavan alle.
</p>

<p>
Make on alunperin kirjoitettu ohjelmoijien työvälineeksi, mutta tätä
voi aivan hyvin käyttää kaikenlaiseen puuhasteluun. Make vahtii
sitäkin, että jos jokin esivaatimuksista on muuttunut (ei kovin
yleistä talonrakennuksessa, mutta tietokoneiden parissa voi
esimerkiksi tiedostoa muokata, jolloin se muuttuukin) niin siitä
riippuvat komponentit tehdään uudestaan.
</p>

<p>
Esimerkiksi tämä opas käyttää Makefileä apunaan tekemään HTML- ja
LaTeX-versiot lähdekielisistä teksteistä. Editorissani ei tarvitse
kuin komentaa <code>make</code> ja uusi versio tulla tupsahtaa maailmaan. Maken
avulla voisi myös omista piirusteluprojekteista ottaa nopeasti
backupeja tai siistiä hakemistoa. Makefileeseen voi myös kirjoitella
lyhyitä skriptinpätkiäkin ilman esivaatimuksia, jos ei halua turhaan
sotkea hakemistojaan pienillä koodinpalasilla.
</p>
</div>
</div>
</div>
</div>
</div>
  <hr />
  <div id="comments"><div id="disqus">
    <div id="disqus_thread"></div>

    <script type="text/javascript">
        var disqus_shortname = 'progim';
        var disqus_identifier = '20140519_1718';

        (function() {
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] ||
            document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>
        <a href="http://disqus.com/?ref_noscript">Disqus</a> vaatii JavaScript-tuen
        toimiakseen.
    </noscript> 
    <a class="dsq-brlink" href="http://disqus.com">
        comments powered by <span class="logo-disqus">Disqus</span>
    </a>
</div></div>
</div>
      <div id="footer"></div>
    </div>
  </body>

</html>