<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <script type="text/x-mathjax-config">
        /* Fix org-generated pictures to MathJX. Big thanks to Davide Cervone
          on StackOverflow with this. http://stackoverflow.com/a/14631703/308668
          */
        MathJax.Extension.myImg2jax = {
            version: "1.0",
            PreProcess: function (element) {
                var images = element.getElementsByTagName("img");
                for (var i = images.length - 1; i >= 0; i--) {
                    var img = images[i];
                    if (img.className === "dvipng") {
                        var script = document.createElement("script");
                        script.type = "math/tex";
                        var match = img.alt.match(/^(\$\$?)(.*)\1/);
                        if (match[1] === "$$") {script.type += ";mode=display"}
                        MathJax.HTML.setScript(script,match[2]);
                        img.parentNode.replaceChild(script,img);
                    }
                }
            }
        };
        MathJax.Hub.Register.PreProcessor(["PreProcess",MathJax.Extension.myImg2jax]);
    </script>
    <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript">
    </script>
    <link href="/templates/main.css" media="screen" type="text/css" rel="stylesheet" />
  
  <title>Yksinkertainen snipettijärjestelmä ZSH:lle — fwwm.us</title>
  <link />
</head>
  <body>
    <div id="backgrounds">
      <div id="header">
        <h1 id="site-title">fwwm.us</h1>
      </div>
      <div id="sidebar">
  <ul id="navigation" class="navi-list">
    <li><a href="/">Ylös</a></li>
    <li><a href="/all.html">Kaikki jutut</a></li>
    <!-- <li><a href=".">RSS</a></li> -->
  </ul>
  <ul class="info-list">
    <li>
      <div>
        <span class="value" id="post-created">22.07.2014</span>
        <span class="key">Luotu</span>
      </div>
    </li>
    <li>
      <div>
        <span class="value" id="post-modified">22.07.2014</span>
        <span class="key">Päivitetty</span>
      </div>
    </li>
    <li>
      <a href="https://github.com/progo/fwwmus---org/commits/main/miete/zsh-snipetit.org" id="post-revs-url">
        <span>Muutoshistoria</span>
      </a>
    </li>
  </ul>

  <h2>Tagit</h2>
  <ul id="tags" class="tag-list"><li class="tag-2"><a href="/tags/koodi.html" class="tag-name">koodi</a></li><li class="tag-0"><a href="/tags/zsh.html" class="tag-name">zsh</a></li></ul>

  <h2 id="related-posts-title">Aiheen vierestä</h2>
  <ul id="related-posts">
    <li>
      <a href="/miete/pelisavetukset-versiohallintaan.html" class="rp-url">
        <span class="rp-title">Pelisavetukset versiohallintaan</span>
      </a>
    </li><li>
      <a href="/miete/naytonsaastajaskriptit.html" class="rp-url">
        <span class="rp-title">Näytönsäästäjäskriptit</span>
      </a>
    </li><li>
      <a href="/miete/lisp-kirjat.html" class="rp-url">
        <span class="rp-title">Lisp-kirjoja</span>
      </a>
    </li><li>
      <a href="/miete/zsh-zle.html" class="rp-url">
        <span class="rp-title">Zsh ja ZLE</span>
      </a>
    </li><li>
      <a href="/miete/illuminatukseni.html" class="rp-url">
        <span class="rp-title">Illuminatukseni</span>
      </a>
    </li>
  </ul>
</div>
      <div id="main">
  <div id="content">
<h1 class="title">Yksinkertainen snipettijärjestelmä ZSH:lle</h1>
<div class="outline-2" id="outline-container-sec-1">

<div id="text-1" class="outline-text-2">

<p>
Tuli tuossa sunnuntaina yks-kaks mieleen, että <a href="zsh-zle.html">ZLE:n ansiosta</a> ZSH:lle
olisi aika helppoa kirjoittaa kunnollinen snipettijärjestelmä.
Snipetithän ovat TextMatesta kaikkialle kopioitu fiksu systeemi, jolla
aliakset ja tekstieditoreissa käytetyt "lyhenteet" (abbreviations)
saadaan vuorovaikutteisiksi. Snipetit toimivat pääsääntöisesti siten,
että tietyn aktivointitekstin kirjoitettuaan painetaan pikanäppäintä
– aika usein tabia – ja aktivoiva teksti käännetään laajennettuun
muotoonsa. Emacsissa on esimerkiksi paketti nimeltä <i>yasnippets</i> ja
vimille on ainakin <i>SnipMate</i> ja modernimpi <i>UltiSnips</i>.
</p>

<p>
Komentoriveillä on näitä lyhenteitä ja erityisemmin aliaksia jo
tarjolla, mutta ne eivät aina tarjoa parasta käytettävyyttä. Joskus
aliakset puretaan auki vasta kun rivi on hyväksytty suoritettavaksi.
Jos aliaksen laajennusta ei satu muistamaan, tai sitä haluaisi muokata
pikkuisen, voi olla hieman haasteellista. (ZSH tosin saattaa tarjota
tabista tehtävää laajennusta ns. inline-aliaksille, mutta tähän en
jaksanut perehtyä.)
</p>

<p>
Koska simppeleitä ZLE-funktioita on tullut kirjoiteltua jo useita, oli
pohjaratkaisu jo visualisoituna mielessä. Tällä snipettisysteemillä
pystyn lisäksi siivoamaan muita interaktiivisia aliaksia pois
konffeistani. Turhaa sotkua ja hankala muistaa kaikkia lisäksi. Koska
shell-skriptaus on ikävää, ja ZSH-skriptaus vielä erityisen huonoa,
päätin ulkoistaa ison työn pythonille. Tuloksena syntyi tämmöinen
ulkoisesti funktionaalinen ilmestys:
</p>

<div class="org-src-container">

<pre class="src src-python"><span class="code-comment-delimiter">#</span><span class="code-comment">!/usr/bin/env python3</span>
<span class="code-keyword">import</span> sys

<span class="code-variable-name">SNIPPETS</span> = {
    <span class="code-string">'j'</span>: (<span class="code-string">'j ""'</span>,
          (<span class="code-string">'end-of-line'</span>, <span class="code-string">'backward-char'</span>)),
    <span class="code-string">'ww'</span>: (<span class="code-string">'WatchNext;WatchNext'</span>,
           (<span class="code-string">'end-of-line'</span>,)),
    <span class="code-string">'wd'</span>: (<span class="code-string">'WatchNext -d'</span>,)
}

<span class="code-keyword">def</span> <span class="code-function-name">main</span>(argv):
    <span class="code-keyword">if</span> <span class="code-keyword">not</span> argv: <span class="code-keyword">return</span>
    <span class="code-builtin">buffer</span> = argv[-1].split(<span class="code-string">' '</span>) <span class="code-comment-delimiter"># </span><span class="code-comment">spaces intact</span>
    <span class="code-variable-name">evals</span> = <span class="code-string">''</span>
    <span class="code-variable-name">match</span> = SNIPPETS.get(<span class="code-builtin">buffer</span>[-1])
    <span class="code-keyword">if</span> match:
        <span class="code-builtin">buffer</span>[-1] = match[0]
        <span class="code-keyword">try</span>:
            <span class="code-variable-name">evals</span> = <span class="code-string">';'</span>.join(match[1])
        <span class="code-keyword">except</span> <span class="code-type">IndexError</span>:
            <span class="code-keyword">pass</span>
    <span class="code-builtin">buffer</span> = <span class="code-string">' '</span>.join(<span class="code-builtin">buffer</span>)
    <span class="code-keyword">print</span> (<span class="code-builtin">buffer</span> + <span class="code-string">"\0"</span> + evals)

<span class="code-keyword">if</span> <span class="code-builtin">__name__</span> == <span class="code-string">'__main__'</span>:
    main(sys.argv[1:])
</pre>
</div>

<p>
Tämä skripti on sellaisenaan testattavissa komentoriviltä. Se odottaa
yhtä argumenttia, komentokehotteen koko sisältöä. Simppelin
ensivedoksen nimissä oletan, että snipettejä halutaan laajentaa vain
rivin lopussa. Jatkoversio voisi ottaa myös kursorin paikan
informaation talteen ja laajentaa snipettejä halutusta kohdasta.
</p>

<p>
Syötteet ovat siis kovakoodattuna tässä kuvauksessa <code>SNIPPETS</code>, ja
kukin snipetti sisältää sekä laajennetun muotonsa että mahdollisia
lisäkäskyjä komentoriville annettavaksi. Jos esimerkiksi komentoa
<code>end-of-line</code> ei anna, kursori säilyy alkuperäisessä paikassaan.
Ensimmäisessä esimerkissä käytän lisäksi komentoa <code>backward-char</code>,
jotta kursori liikkuu automaagisesti laajennetun tekstin
lainausmerkkien sisään. Käytettävyys!
</p>

<p>
Jatkokehittelyä voisivat olla kutsuttavat (callable) laajennukset, eli
snipetin laajennus olisi dynaamista sisältöä funktiokutsun laskemana.
Tällä tavalla saisi aikaan erään suosikkisnipettini vimistä ja
emacsista: <code>date</code> laajenee tämänpäiväiseen ISO-muotoiltuun
päivämäärään. Samalla tavalla voisi kirjoittaa snipetin <code>nfile</code>, joka
laajenee hakemiston tuoreimman tiedoston nimeen.
</p>

<p>
Ja tämä skripti palauttaa kaksi arvoa takaisin: ensimmäinen on
mahdollisesti muokattu versio komentokehotteen sisällöstä ja
jälkimmäinen arvo on lista ZSH/ZLE-komentoja, jotka shelli saisi
suorittaa makunsa mukaan käyttäjäkokemuksen maksimoimiseksi. Erotan
nämä palautteet toisistaan erotinmerkeistä parhaimmalla, eli
nollatavulla.
</p>

<p>
Tämä skripti on minulla tallennettuna omaan paikkaani
kotihakemistossa. Ja sitten vielä lisätään sopiva koodi ZSH:n
konfiguraatioihin:
</p>

<div class="org-src-container">

<pre class="src src-sh"><span class="code-keyword">function</span> <span class="code-function-name">_expand_snippet</span>() {
    <span class="code-variable-name">IFS</span>=$<span class="code-string">'\0'</span> <span class="code-variable-name">output</span>=(<span class="code-sh-quoted-exec">`/home/progo/pika/__zsh_snippets.py "$BUFFER"`</span>)
    <span class="code-variable-name">BUFFER</span>=<span class="code-string">"$output[1]"</span>
    <span class="code-keyword">if</span> [[ -n <span class="code-string">"$output[2]"</span> ]] ;<span class="code-keyword">then</span>
        <span class="code-comment-delimiter"># </span><span class="code-comment">extra commands to eval!</span>
        <span class="code-builtin">eval</span> <span class="code-string">"$output[2]"</span>
    <span class="code-keyword">fi</span>
}
zle -N expand_snippet _expand_snippet
<span class="code-builtin">bindkey</span> <span class="code-string">"^E"</span> expand_snippet
</pre>
</div>

<p>
Funktio <code>_expand_snippet</code> on nyt ZLE-funktio, jossa toimii kaikki
shell-skriptaus sellaisenaan. Erityisesti siellä on käytettävissä
<code>BUFFER</code>-niminen muuttuja, jossa on komentokehotteen nykysisältö. Sitä
saa vapaasti muokata ja muutokset näkyvät suoraan rivillä. Kutsun
oitis pythonia ja otan vastaustavaran taulukkoon. Käytän tyylikkäästi
<code>eval</code>-kutsua suorittaakseni lisäkomennot vähällä vaivalla. Nämä
lisäkomennot voivat käytännössä olla mitä tahansa shell-koodausta,
mutta ZLE-funktioissa saa myös käyttää ZLE-funktioita, kuten
edellämainittuja kursorinliikekomentoja <code>end-of-line</code>, <code>forward-char</code>
ja niin edespäin. Konsultoi näppäinkarttojasi saadaksesi selville
täydet listat mahdollisista komennoista.
</p>

<p>
Funktio pitää rekisteröidä ZLE:n käytettäväksi ja sitten se mapataan
johonkin näppiin. Vi-näppäimiä käyttävillä on kissanpäivät vapaiden
yhdistelmien suhteen, ja minä laitoin roskan <code>C-e</code>:n taakse.
</p>

<p>
Ja ZSH:lla homma toimii. Bashillahan tämä ei onnistu lainkaan tällä
keinoin, koska readline ei tarjoa tarpeeksi rajapintoja näin
yksilöllistä koodia varten. Toivottavasti tästä on hyötyä ja herättää
kiinnostusta ja toivoa komentoriviä kohtaan.
</p>
</div>
</div>
</div>
  <hr />
  <div id="comments"><div id="disqus">
    <div id="disqus_thread"></div>

    <script type="text/javascript">
        var disqus_shortname = 'progim';
        var disqus_identifier = '20140722_1723';

        (function() {
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] ||
            document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>
        <a href="http://disqus.com/?ref_noscript">Disqus</a> vaatii JavaScript-tuen
        toimiakseen.
    </noscript> 
    <a class="dsq-brlink" href="http://disqus.com">
        comments powered by <span class="logo-disqus">Disqus</span>
    </a>
</div></div>
</div>
      <div id="footer"></div>
    </div>
  </body>

</html>