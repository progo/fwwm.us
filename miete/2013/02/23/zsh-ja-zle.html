<html><head><meta content="text/html; charset=utf-8" http-equiv="content-type" /><script type="text/x-mathjax-config">/* Fix org-generated pictures to MathJX. Big thanks to Davide Cervone
  on StackOverflow with this. http://stackoverflow.com/a/14631703/308668
  */
MathJax.Extension.myImg2jax = {
    version: "1.0",
    PreProcess: function (element) {
        var images = element.getElementsByTagName("img");
        for (var i = images.length - 1; i >= 0; i--) {
            var img = images[i];
            if (img.className === "dvipng") {
                var script = document.createElement("script");
                script.type = "math/tex";
                var match = img.alt.match(/^(\$\$?)(.*)\1/);
                if (match[1] === "$$") {script.type += ";mode=display"}
                MathJax.HTML.setScript(script,match[2]);
                img.parentNode.replaceChild(script,img);
            }
        }
    }
};
MathJax.Hub.Register.PreProcessor(["PreProcess",MathJax.Extension.myImg2jax]);
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script><link href="http://fwwm.us/css/main.css" rel="stylesheet" type="text/css" /><title>Zsh ja ZLE - Life at the Room.</title><link href="http://fwwm.us/css/miete.css" rel="stylesheet" type="text/css" /></head><body><div id="sidebar-left"><div id="post-info"><div id="navi"><span class="title">Navigointi</span><ul id="navi-list"><li class="fp"><a href="http://fwwm.us/">Etusivulle</a></li><li><a href="http://fwwm.us/miete/index.html">Mietteet</a></li><li><a href="..">helmikuu</a></li><li><a href="../..">2013</a></li></ul></div><span class="title">Info</span><p class="date">Julkaistu<br />23.02.2013 20:42</p></div><div id="post-tags"><span class="title">Tagit</span><ul id="tags-list"><li><div class="taggy"><div class="taggy-inner"><a href="http://fwwm.us/tag/zsh/index.html">zsh</a></div></div></li></ul></div></div><div id="content"><div class="post-content">
<h1>Zsh ja ZLE    </h1>
<div id="text-2-26" class="outline-text-3">




<p>   
   Suuri ja pelottava <a href="http://zsh.sourceforge.net/">zsh</a> on suurilta osin niin lähellä de-facto
   -standardia, <code>bashia</code>, että päällisin puolin eroja ei tunnu olevan.
   Mutta kun asiat etenevät, on zsh tarpeen tullen paljon notkeampi ja
   tässä viestissä kerron esimerkin viimeaikaisista keksimisistäni.
</p>

</div>

<div class="outline-4" id="outline-container-2-26-1">
<h2>Readline</h2>
<div id="text-2-26-1" class="outline-text-4">


<p>
   Kuten me kaikki tiedämmekin, bashin salaisuus on aina ollut upea
   komentorivikokemus. Se irrotettiinkin myöhemmin omaksi
   <code>readline</code>-kirjastokseen kaikkien saataville. Readline osaa
   useimpien terminaalien näppärät kikat ja lukee näppäinyhdistelmiä
   hyvin. Tukeepa jopa vi-näppäimiä, vaikka oletuksena käytössä olevat
   emacs-näppäimet ovat yhdellä rivillä pujotellessa usein riittävät.
</p>
<p>
   Readlineen tietenkin kirjoitettu ja jätetty auki mahdollisuus
   lisätä uusia näppäinyhdistelmiä toiminnoille ja tabitäydennystä
   varten voi sille antaa <i>callback</i>-funktion, jolla esimerkiksi
   saadaan omat älykkäät tabitäydennykset kuntoon.
</p>
<p>   
   Mutta siihenpä readlinen toiminnot vain riittävätkin. Muutamia
   puutteita, joita olen vuosien saatossa havainnut:
</p>
<ul>
<li>Readline ei esimerkiksi anna kirjoittaa uusia funktioita
     interaktiiviseen käyttöön.
</li>
<li>Vi-moodissa hyödyllistä moodi-indikaattoria lisäystilan ja
     normaalin tilan välillä saa mitenkään aikaan, koska se vaatisi
     readlinen ja bashin välistä ylimääräistä kommunikointia.
</li>
<li>Komentorivin väritys ei tule kysymykseenkään.
</li>
</ul>


<p>
   Toisin kuin valtaosa shelleistä bashin lisäksi, zsh ei käytä
   readlinea käyttäjäinputin lukemiseen, vaan sillä on aivan oma
   lukija, ZLE: Zsh (Command) Line Editor. Ja ZLE osaa kaikki
   edellämainituista toivomuksista puhtain paperein.
</p>
</div>

</div>

<div class="outline-4" id="outline-container-2-26-2">
<h2>ZLE</h2>
<div id="text-2-26-2" class="outline-text-4">


<p>    
    (Tänne saatan lisätä hyperlinkit detaljeja sisältäviin
    postauksiin, jahka kirjoitan tai backporttaan ne vanhasta
    blogista. Nyt saatte mennä summariikeilla.)
</p>
<p>    
    Se oli luultavasti tuo Vi-moodi-indikaattori, josta ylipäätään
    tein hypyn zsh:aan. Olin ymmärtänyt, että päällisin puolin ja
    peruskäytössä bashin ja zsh:n välillä ei ole <i>mitään</i> eroa. Ja
    ymmärsin aivan oikein.
</p>
<p>    
    Ensin otin vi-moodi-indikaattorin tuunauksen alle; lopulta päädyin
    värilliseen kehotteeseen siten, että vihreä kehote viitaa
    lisäysmoodiin ja tumma kehote viittaa normaalitilaan.
    Komentorivillä ei kamalan paljoa ylipäätään tarvitse
    normaalitilaan siirryskelläkään, eikä ne siirtymät normaalitilaan
    edes aina kestä niin pitkään, että kehotteen väri ehtisi pieneltä
    viiveeltään vaihtua. Mutta onpahan kiva, jos joskus jää
    normaalitila päälle. Tiedän varoa.
</p>
<p>    
    Sitten luin syntaksivärjäyksestä komentoriville, ja se idea
    natsasi oitis: vaadimmehan me kaikki syntaksivärjäystä
    koodieditoreissammekin. Miksei sitten tuossa interaktiivisessa
    shell-skriptiä syövässä editorissamme? ZLE:n ansiosta näen
    punaisella komennot, joita zsh ei löydä polulta, vaalealla ne
    komennot, jotka ovatkin oikeasti shell-aliaksia tai -funktioita ja
    tärkeämpänä ryhmittelevät sulut ja alishellit. Kaikki tämmöinen
    onnistuu ja auttaa kirjoittamaan oikeita komentorimpsuja.
    Koodinvärjäys ei ole pelkkää karkkia tyyliin: "hei, tuossa on <code>if</code>
    ja tuossa <code>echo</code>", vaan tällä värjäyksellä voi esimerkiksi laittaa
    lainattu teksti todella erottumaan muista komennoista: suunnaton
    etu kun näkee välittömästi, mitä se shell aikoo muuttujalaajentaa
    ja mitä ei.
</p>
<p>    
    Ja kolmantena nuo omat funktiot tai <i>widgetit</i>, kuten
    ZLE-terminologiassa puhutaan. Jos olet yhtään readlinea tai zle:tä
    konffannut käyttäjänä niin tämmöinen funktio tai widget on jollain
    tavalla interaktiivinen rutiini, jolla käyttäjä toimii
    komentorivillä. Esimerkiksi funktio <code>end-of-line</code> on sekä
    readlinen että ZLE:n widget, joka vie kursorin rivin loppuun ja on
    oletuksena kytketty <code>C-e</code> -näppäinyhdistelmään.
</p>
<p>    
    Ja nyt opiskelin hieman, miten kirjoitetaan oma widget ZLE:lle.
    Taustalle sellainen juttu, että kirjoitettuani alkuperäisen
    thinktank-systeemini loin luonnollisesti komentoriville sopivan
    <code>think</code>-aliaksen. Alias siksi, jotta voin käyttää asteriskeja ja
    kysymysmerkkejä ilman shellin vinkumista.
</p>
<p>
    Lisäsin sille vielä pikanäppäimen, koska olen sellainen ihminen.
    Tuloksena seuraa tämäntapaista koodia <code>.zshrc</code>-tiedostoon:
</p>



<pre class="example">alias think='noglob org_capture.sh '

bindkey -s "^t" "think "
</pre>


<p>    
    Kätevää ja tehokasta. Think-systeemini kehittyi hiljalleen ja
    orgin toimiessa taustalla olisi mukavaa saada TODO-leima
    välittömästi mukaan toimia vaativaan ajatukseen. Tämän voisi
    kirjoittaa aina manuaalisesti <code>think</code>-komennon perään, mutta onpa
    se työlästä. Ja oma alias todo-jutulle tuntuu aika kovalta.
</p>
<p>    
    Paras ratkaisu, ainakin mielestäni, olisi saada samasta
    näppäimestä ensin paljas <code>think</code> ja sitten toisella kerralla
    TODO:llinen <code>think</code>. Pieni googlaus, muutama greppaus zsh:n
    manpageilta ja pari senttilitraa kylmää hikeä tuotti seuraavan
    widgetin:
</p>



<pre class="example">function _-thinktodo()
{
    if [[ "$BUFFER" == "" ]] ;then
        BUFFER="think "
    elif
        [[ "$BUFFER" == "think " ]] ;then
        BUFFER="think TODO "
    fi
    end-of-line
}
# new widget
zle -N thinktodo _-thinktodo
bindkey "^t" thinktodo
</pre>


<p>    
    Zsh:n dokumentaatio on referenssinä hyvää, mutta siihen on vaikea
    päästä sisään ulkopuolisen. Onneksi tässä asiassa tuli vastaan
    onnekas esimerkki monimutkaisemmasta widgetistä, ja nähdessäni
    <code>$BUFFER</code>-nimisen muuttujan kävi sisäinen päättelyni toimiin.
    Manpagelta greppaamalla varmistuin kyseisen muuttujan käytöstä.
</p>
<p>    
    Uusi funktio pitää esitellä widgetiksi sisäänrakennetun
    <code>zle</code>-kutsun kanssa ja sitten se onkin valmis bindattavaksi. Ja
    toimii yllättävän hienosti. Huomattavissa on, että widgettien
    määrittely ja toiminnallisuus on kovasti samannäköistä kuin
    Emacsin interaktiivisten funktioiden kanssa.
</p>
<p>    
    Nämä widgetit voivat olla kovinkin hienoja: StackOverflow'ssa
    esiteltiin emacs-henkinen, interaktiivinen search-replace
    -widgetti. Kysyy siis ensin etsittävää patternia ja sitten
    korvaajaa. Ja tavallisina funktioita widgetit voi vaikka tehdä
    googlauksen curlin avulla tuossa välissä.
</p>
<p>    
    Tälle on tulossa toivottavasti isoa käyttöä pian.
</p>
</div>

</div>

<div class="outline-4" id="outline-container-2-26-3">
<h2>Pari muuta esimerkkiä ZLE:lle</h2>
<div id="text-2-26-3" class="outline-text-4">


<p>
    <a href="http://stackoverflow.com/questions/171563/whats-in-your-zshrc">StackOverflow</a>'ssa on tietenkin kysymys (nyt lukittu) zsh-kikoista.
    Monella on esitellä näppäriä zle-widgettejä.
</p>
<p>    
    Esimerkiksi <b>alamar</b> on keksinyt kirjoittaa jotain pientä
    <code>sudo</code>-komenteluihin; <code>M-s</code> lisää sudo-tekstin komentorivin alkuun.
</p>



<pre class="example">insert_sudo () { zle beginning-of-line; zle -U "sudo " }
zle -N insert-sudo insert_sudo
bindkey "^[s" insert-sudo
</pre>


<p>    
    Kysymyksen paras vastaus on <b>Frew</b>'n massiivinen konffi.
    Tuollainen määrä aliaksia ei kyllä tee mielestäni hyvää
    muistikuormalle tai muutenkaan. Olen pohtimassa jonkin sortin
    snippet- tai abbr-moodia zsh:lle ja laajennettavat aliakset
    voisivat olla kova sana.
</p>
</div>
</div>

</div><div id="disqus_thread"></div>

<script type="text/javascript">
    // :sb__ stuff is replaced in clojure
    var disqus_shortname = 'progim';
    var disqus_identifier = '20130223_2042';

    (function() {
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] ||
         document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>

<noscript>Please enable JavaScript to view the <a
href="http://disqus.com/?ref_noscript">comments powered by
Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by
<span class="logo-disqus">Disqus</span></a>
</div></body></html>